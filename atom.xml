<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://blog.lee81.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.lee81.cn/"/>
  <updated>2022-08-13T12:29:03.596Z</updated>
  <id>https://blog.lee81.cn/</id>
  
  <author>
    <name>八一</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一道笔试题</title>
    <link href="https://blog.lee81.cn/2022/08/13/%E8%AE%B0%E4%B8%80%E9%81%93%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>https://blog.lee81.cn/2022/08/13/%E8%AE%B0%E4%B8%80%E9%81%93%E7%AC%94%E8%AF%95%E9%A2%98/</id>
    <published>2022-08-13T12:29:03.596Z</published>
    <updated>2022-08-13T12:29:03.596Z</updated>
    
    <content type="html"><![CDATA[<p>今天参加了一场笔试，有一道题写出来了，但是有些小问题，在这里记录一下。</p><h3 id="1、题目"><a href="#1、题目" class="headerlink" title="1、题目"></a>1、题目</h3><p>创建一个线程类，实例化三个线程A,B,C，要求线程A打印A，线程B打印B，线程C打印C，然后开启线程的顺序为C -&gt; B -&gt; A，打印结果为：</p><p>A</p><p>B</p><p>C</p><h3 id="2、错误思路"><a href="#2、错误思路" class="headerlink" title="2、错误思路"></a>2、错误思路</h3><p>看到题目的时候，我的第一反应是使用线程通信去做，然后就有了下面的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程，按 C-&gt;B-&gt;A的顺序开启</span></span><br><span class="line">        c.start();</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//创建锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建临时标识，用于表示当前执行那个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果flag为0，并且是线程A</span></span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; <span class="string">&quot;A&quot;</span>.equals(msg)) &#123;</span><br><span class="line">                    <span class="comment">//打印A</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="comment">//将flag设置为1</span></span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//唤醒其他线程</span></span><br><span class="line">                    condition.signal();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span> &amp;&amp; <span class="string">&quot;B&quot;</span>.equals(msg)) &#123;<span class="comment">//如果flag为1，并且是线程B</span></span><br><span class="line">                    <span class="comment">//打印B</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="comment">//将flag设置为2</span></span><br><span class="line">                    flag = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//唤醒其他线程</span></span><br><span class="line">                    condition.signal();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span> &amp;&amp; <span class="string">&quot;C&quot;</span>.equals(msg)) &#123;<span class="comment">//如果flag为2，并且是线程C</span></span><br><span class="line">                    <span class="comment">//打印C</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是其他情况就阻塞住当前线程</span></span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、正确解法"><a href="#3、正确解法" class="headerlink" title="3、正确解法"></a>3、正确解法</h3><p>面试官说有些问题，所以我就进行了改进，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程，按 C-&gt;B-&gt;A的顺序开启</span></span><br><span class="line">        c.start();</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//创建锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建临时标识，用于表示当前执行那个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果flag为0，并且是线程A</span></span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; <span class="string">&quot;A&quot;</span>.equals(msg)) &#123;</span><br><span class="line">                    <span class="comment">//打印A</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="comment">//将flag设置为1</span></span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//唤醒B线程</span></span><br><span class="line">                    conditionB.signal();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span> &amp;&amp; <span class="string">&quot;B&quot;</span>.equals(msg)) &#123;<span class="comment">//如果flag为1，并且是线程B</span></span><br><span class="line">                    <span class="comment">//打印B</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="comment">//将flag设置为2</span></span><br><span class="line">                    flag = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//唤醒C线程</span></span><br><span class="line">                    conditionC.signal();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span> &amp;&amp; <span class="string">&quot;C&quot;</span>.equals(msg)) &#123;<span class="comment">//如果flag为2，并且是线程C</span></span><br><span class="line">                    <span class="comment">//打印C</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果上面的情况不符合，就要阻塞当前线程</span></span><br><span class="line">                <span class="comment">//如果当前线程为B，并且flag不为1，就阻塞</span></span><br><span class="line">                    <span class="keyword">if</span>(flag != <span class="number">1</span> &amp;&amp; <span class="string">&quot;B&quot;</span>.equals(msg))&#123;</span><br><span class="line">                        conditionB.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果当前线程为C，并且flag不为2，就阻塞</span></span><br><span class="line">                    <span class="keyword">if</span>(flag != <span class="number">2</span> &amp;&amp; <span class="string">&quot;C&quot;</span>.equals(msg))&#123;</span><br><span class="line">                        conditionC.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、其他解法"><a href="#4、其他解法" class="headerlink" title="4、其他解法"></a>4、其他解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Print</span> <span class="variable">print</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Print</span>();</span><br><span class="line">        <span class="comment">//开启线程C</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printC();</span><br><span class="line">        &#125;,<span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启线程B</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printB();</span><br><span class="line">        &#125;,<span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启线程A</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print.printA();</span><br><span class="line">        &#125;,<span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印A</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//如果flag不为0，就将当前线程等待</span></span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditionA.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印a</span></span><br><span class="line">            System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">            <span class="comment">//将flag设置为1</span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//唤醒B线程</span></span><br><span class="line">            conditionB.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印B</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//如果flag不为1，就将当前线程等待</span></span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditionB.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印a</span></span><br><span class="line">            System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">            <span class="comment">//将flag设置为2</span></span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//唤醒C线程</span></span><br><span class="line">            conditionC.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印C</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//如果flag不为2，就将当前线程等待</span></span><br><span class="line">            <span class="keyword">while</span>(flag != <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditionC.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印a</span></span><br><span class="line">            System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            <span class="comment">//将flag设置为0</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//唤醒C线程</span></span><br><span class="line">            conditionA.signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><p>这场面试我是非常看重的，但是因为当时家里断网，加上自己紧张，没有做出来，不说了，都是泪。归根到底就是一句话还是自己太菜，不找任何理由，继续加油吧。</p><h3 id="6、后续"><a href="#6、后续" class="headerlink" title="6、后续"></a>6、后续</h3><p>第二天我又研究了一下我写错的代码，发现我只是用错了一个方法，就是将代码中的 signal() 修改为 signalAll() 即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建三个线程</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程，按 C-&gt;B-&gt;A的顺序开启</span></span><br><span class="line">        c.start();</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//创建锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建临时标识，用于表示当前执行那个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果flag为0，并且是线程A</span></span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span> &amp;&amp; <span class="string">&quot;A&quot;</span>.equals(msg)) &#123;</span><br><span class="line">                    <span class="comment">//打印A</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="comment">//将flag设置为1</span></span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//唤醒其他线程，错误就在这里，只需修改为signalAll()就可以了</span></span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">1</span> &amp;&amp; <span class="string">&quot;B&quot;</span>.equals(msg)) &#123;<span class="comment">//如果flag为1，并且是线程B</span></span><br><span class="line">                    <span class="comment">//打印B</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="comment">//将flag设置为2</span></span><br><span class="line">                    flag = <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//唤醒其他线程,这里也是一样</span></span><br><span class="line">                    condition.signalAll();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag == <span class="number">2</span> &amp;&amp; <span class="string">&quot;C&quot;</span>.equals(msg)) &#123;<span class="comment">//如果flag为2，并且是线程C</span></span><br><span class="line">                    <span class="comment">//打印C</span></span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是其他情况就阻塞住当前线程</span></span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天参加了一场笔试，有一道题写出来了，但是有些小问题，在这里记录一下。&lt;/p&gt;
&lt;h3 id=&quot;1、题目&quot;&gt;&lt;a href=&quot;#1、题目&quot; class=&quot;headerlink&quot; title=&quot;1、题目&quot;&gt;&lt;/a&gt;1、题目&lt;/h3&gt;&lt;p&gt;创建一个线程类，实例化三个线程A,B,</summary>
      
    
    
    
    <category term="笔试题" scheme="https://blog.lee81.cn/categories/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="笔试题" scheme="https://blog.lee81.cn/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="https://blog.lee81.cn/2021/04/28/%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blog.lee81.cn/2021/04/28/%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-04-28T07:03:04.000Z</published>
    <updated>2022-09-07T11:57:34.274Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近工作太忙，没有时间排版，先发思维导图吧，后续有空再好好排版发出来。</p></blockquote><p>思维导图地址：<a href="https://www.processon.com/view/link/63175062e0b34d331332445d">https://www.processon.com/view/link/63175062e0b34d331332445d</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近工作太忙，没有时间排版，先发思维导图吧，后续有空再好好排版发出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思维导图地址：&lt;a href=&quot;https://www.processon.com/view/link/63175062e0b34d3</summary>
      
    
    
    
    <category term="线程" scheme="https://blog.lee81.cn/categories/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="线程" scheme="https://blog.lee81.cn/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>算法--插入排序</title>
    <link href="https://blog.lee81.cn/2020/08/08/%E7%AE%97%E6%B3%95--%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>https://blog.lee81.cn/2020/08/08/%E7%AE%97%E6%B3%95--%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</id>
    <published>2020-08-08T14:32:27.000Z</published>
    <updated>2022-08-13T12:29:03.594Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>插入排序思想：对一个未排序的数组来说，将第一值当做已经被排好序的数组，然后从第二个值开始循环向前面排好序的数组进行比较插入。比较的顺序是从被排好序的数组的最后向前比较。</p><h3 id="2、图解示例"><a href="#2、图解示例" class="headerlink" title="2、图解示例"></a>2、图解示例</h3><p><img src="%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg"></p><p>观察可得：</p><ol><li>对数组排序需要进行 length - 1 轮遍历，并且将数组第一个值当做已经排好序的数组，从第二个值开始进行插入。</li><li>每轮开始比较的位置为要插入的数据的下标 - 1。</li><li>进行插入时：<ul><li>如果要插入的数据小于被比较的数据时，就将被比较的数据向后移一位，然后将被比较的下标 - 1，进行下轮的比较。</li><li>如果下标 - 1已经超过了0，那说明要插入的数据为最小值，即插入到第一位。</li><li>如果要插入的数据大于被比较的数据时，就将要插入的数据插入到被比较的数据后一位。</li></ul></li></ol><h3 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ld.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ld</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/8 22:38</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 算法--插入排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 对于一个未排序的数组来说，将第一值当做已经被排好序的数组，然后从第二个值开始循环向前面排好序的数组进行比较插入。</span></span><br><span class="line"><span class="comment"> * 比较的顺序是从被排好序的数组的最后向前比较。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待排序的数组</span></span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">29</span>,<span class="number">10</span>,-<span class="number">3</span>,<span class="number">90</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行插入排序</span></span><br><span class="line">        <span class="type">int</span>[] sortArray = sort(array);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排好序的数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span> + Arrays.toString(sortArray));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行插入排序，从小到大排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回排序后的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将第一值当做已经被排好序的数组，然后从第二个值开始循环向前面排好序的数组进行插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            <span class="comment">//要插入的数据</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> array[i];</span><br><span class="line">            <span class="comment">//定义被插入的数组的结束位置，也是比较的开始位置。即要插入的数据下标减一</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//循环判断当前被比较的下标有没有越界，并且判断插入的值是否小于要被比较的值，</span></span><br><span class="line">            <span class="comment">// 如果小于，就要将当前被比较的值向后移一位</span></span><br><span class="line">            <span class="keyword">while</span>(startIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; array[startIndex])&#123;</span><br><span class="line">                array[startIndex + <span class="number">1</span>] = array[startIndex];</span><br><span class="line">                <span class="comment">//并且将被比较的下标向前移一位，进行下一轮的比较</span></span><br><span class="line">                startIndex--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果不满足上面的条件，</span></span><br><span class="line">            <span class="comment">//就表示插入的值大于被比较的值，所以要将插入的值插入到被比较的值后面。</span></span><br><span class="line">            <span class="comment">//或者前面已经没有数据，将值插入到最前面。</span></span><br><span class="line">            array[startIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a&gt;1、概述&lt;/h3&gt;&lt;p&gt;插入排序思想：对一个未排序的数组来说，将第一值当做已经被排好序的数组，然后从第二个值开始循环向前面排好序的数组进行比较插入。</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.lee81.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.lee81.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://blog.lee81.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法--选择排序</title>
    <link href="https://blog.lee81.cn/2020/08/06/%E7%AE%97%E6%B3%95--%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://blog.lee81.cn/2020/08/06/%E7%AE%97%E6%B3%95--%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</id>
    <published>2020-08-06T13:15:20.000Z</published>
    <updated>2022-08-13T12:29:03.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>选择排序思想：对一组长度为 n 的未排序的数据进行遍历，比较得出最小值和对应的下标，然后将最小值和下标为0的值进行交换，即将最小值放到最前面；然后再从下标为1的位置进行第二轮遍历，比较得出剩余数据中的最小值，并与下标为1的值进行交换；按照这种方式依次遍历，直到完成所有数据的排序。</p><h3 id="2、图解示例"><a href="#2、图解示例" class="headerlink" title="2、图解示例"></a>2、图解示例</h3><p><img src="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg"></p><p>观察可得：</p><ol><li>定义两个临时变量min和index，分别表示最小值和最小值的下标。并且每轮排序开始时，都将min和index的值重置为当前剩余未排序的起始值，然后依次向后遍历比较。</li><li>对数组排序需要进行 length - 1 轮遍历。</li><li>每轮遍历中的数据比较都在依次减少。</li></ol><h3 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ld.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ld</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/6 21:30</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 算法--选择排序</span></span><br><span class="line"><span class="comment"> * 对一组长度为 n 的未排序的数据进行遍历，比较得出最小值和对应的下标，然后将最小值和下标为0的值进行交换，即将最小值放到最前面；</span></span><br><span class="line"><span class="comment"> * 然后再从下标为1的位置进行第二轮遍历，比较得出剩余数据中的最小值，并与下标为1的值进行交换；</span></span><br><span class="line"><span class="comment"> * 按照这种方式依次遍历，直到完成所有数据的排序。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试数据</span></span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">23</span>,<span class="number">1</span>,<span class="number">90</span>,-<span class="number">3</span>,<span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前：&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行选择排序</span></span><br><span class="line">        <span class="type">int</span>[] sortArray = sort(array);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序后：&quot;</span> + Arrays.toString(sortArray));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行选择排序，以升序的方式排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回排序后的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//标识要被交换的下标,初始默认为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//标识为最小值,初始默认为第一个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; array.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            minIndex = i;</span><br><span class="line">            min = array[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; array.length;j++)&#123;</span><br><span class="line">                <span class="comment">//判断当前值是否小于最小值</span></span><br><span class="line">                <span class="keyword">if</span>(array[j] &lt; min)&#123;</span><br><span class="line">                    <span class="comment">//将当前值赋值给min</span></span><br><span class="line">                    min = array[j];</span><br><span class="line">                    <span class="comment">//记录当前下标</span></span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换值</span></span><br><span class="line">            <span class="keyword">if</span>(minIndex != i)&#123;</span><br><span class="line">                array[minIndex] = array[i];</span><br><span class="line">                array[i] = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a&gt;1、概述&lt;/h3&gt;&lt;p&gt;选择排序思想：对一组长度为 n 的未排序的数据进行遍历，比较得出最小值和对应的下标，然后将最小值和下标为0的值进行交换，即将</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.lee81.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.lee81.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://blog.lee81.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法--冒泡排序</title>
    <link href="https://blog.lee81.cn/2020/08/05/%E7%AE%97%E6%B3%95--%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://blog.lee81.cn/2020/08/05/%E7%AE%97%E6%B3%95--%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2020-08-05T06:09:27.000Z</published>
    <updated>2022-08-13T12:29:03.593Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>冒泡排序思想：对一组乱序的数据，从前向后依次比较相邻的俩个元素的值，如果前一个值大于后一个值就交换位置，最后就会将最大的值放到末尾；然后再从前向后开始进行第二轮的比较，将第二大的值排在倒数第二位。就这样循环下去，就会得到一组有序的数据。</p><h3 id="2、图解示例"><a href="#2、图解示例" class="headerlink" title="2、图解示例"></a>2、图解示例</h3><p><img src="%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.PNG"></p><p>观察可得：</p><ol><li>对数组排序需要进行 length - 1 轮遍历。</li><li>每轮遍历中的数据比较都在依次减少。</li><li>优化，当发现某一轮遍历中没有进行数据交换，即表示已经排好序，可以直接结束冒泡排序。</li></ol><h3 id="3、代码"><a href="#3、代码" class="headerlink" title="3、代码"></a>3、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ld.algorithm.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ld</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/5 16:26</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 排序算法--冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 冒泡排序思想：</span></span><br><span class="line"><span class="comment"> * 对一组乱序的数据，从前向后依次比较相邻的俩个元素的值，如果前一个值大于后一个值就交换位置，最后就会将最大的值放到末尾；</span></span><br><span class="line"><span class="comment"> * 然后再从前向后开始进行第二轮的比较，将第二大的值排在倒数第二位。</span></span><br><span class="line"><span class="comment"> * 就这样循环下去，就会得到一组有序的数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//测试数据</span></span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,-<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的数据：&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行冒泡排序</span></span><br><span class="line">        <span class="type">int</span>[] sortArray = sort(array);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数据：&quot;</span> + Arrays.toString(sortArray));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行冒泡排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array 要被排序的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回排序后有序的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//临时变量，用于交换数据时使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用于优化冒泡排序，即如果一轮遍历中，没有进行交换，说明已经排好序</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//本层循环表示要对array进行多少轮遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; array.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="comment">//本层循环用于两两比较</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="comment">//判断前一个值是否大于后一个值,如果大于就交换</span></span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">//如果进行了交换，就设置为true</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    temp = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断一轮遍历后，是否进行了交换</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                <span class="comment">//未交换，直接跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//重置</span></span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a&gt;1、概述&lt;/h3&gt;&lt;p&gt;冒泡排序思想：对一组乱序的数据，从前向后依次比较相邻的俩个元素的值，如果前一个值大于后一个值就交换位置，最后就会将最大的值放</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.lee81.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.lee81.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="https://blog.lee81.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kafka集群搭建</title>
    <link href="https://blog.lee81.cn/2020/05/09/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.lee81.cn/2020/05/09/Kafka%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</id>
    <published>2020-05-09T01:10:44.000Z</published>
    <updated>2022-08-13T12:29:03.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、集群规划"><a href="#1、集群规划" class="headerlink" title="1、集群规划"></a>1、集群规划</h3><table><thead><tr><th>IP地址</th><th>系统</th><th>环境</th></tr></thead><tbody><tr><td>192.168.150.101</td><td>CentOS7</td><td>jdk8，Zookeeper 3.4.14</td></tr><tr><td>192.168.150.102</td><td>CentOS7</td><td>jdk8，Zookeeper 3.4.14</td></tr><tr><td>192.168.150.103</td><td>CentOS7</td><td>jdk8，Zookeeper 3.4.14</td></tr></tbody></table><h3 id="2、下载安装"><a href="#2、下载安装" class="headerlink" title="2、下载安装"></a>2、下载安装</h3><h4 id="2-1、下载"><a href="#2-1、下载" class="headerlink" title="2.1、下载"></a>2.1、下载</h4><p>下载地址：<a href="http://kafka.apache.org/downloads">http://kafka.apache.org/downloads</a></p><p>根据自己的需求，选择相对应的版本，我这是用的是kafka_2.11-1.1.1。</p><p><strong>解释：kafka_2.11-1.1.1中有两个版本号，2.11表示Scala的版本号，1.1.1表示Kafka的版本号。</strong></p><h4 id="2-2、安装"><a href="#2-2、安装" class="headerlink" title="2.2、安装"></a>2.2、安装</h4><p>将下载好的压缩包，解压到自己指定的路径下，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kafka_2.11-1.1.1.tgz -C /opt/module/</span><br></pre></td></tr></table></figure><h3 id="3、配置文件参数说明"><a href="#3、配置文件参数说明" class="headerlink" title="3、配置文件参数说明"></a>3、配置文件参数说明</h3><p>进入到 config/ 目录下，里面有一个 server.properties 文件，这个就是 kafka 的配置文件。这里只介绍部分参数，其他参数请看 <a href="http://kafka.apache.org/documentation/#brokerconfigs">http://kafka.apache.org/documentation/#brokerconfigs</a></p><table><thead><tr><th align="left">参数名</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">broker.id</td><td align="left">-1</td><td align="left">表示该节点在Kafka集群中broker的唯一标识。</td></tr><tr><td align="left">listeners</td><td align="left">无</td><td align="left">表示broker 监听客户端连接的地址列表。配置格式为：protocol://hostname:port。其中protocol 表示协议类型，hostname表示主机名，port表示端口号。</td></tr><tr><td align="left">log.dirs</td><td align="left">/tmp/kafka-logs</td><td align="left">表示用来配置Kafka日志文件存放的根目录。并且可以配置多个根目录（以逗号分隔）。</td></tr><tr><td align="left">num.partitions</td><td align="left">1</td><td align="left">表示主题的分区数。</td></tr><tr><td align="left">log.retention.hours</td><td align="left">168</td><td align="left">表示日志文件的留存时间，单位为小时。</td></tr><tr><td align="left">log.segment.bytes</td><td align="left">1073741824</td><td align="left">表示日志分段文件的最大值，超过这个值会强制创建一个新的日志分段。</td></tr><tr><td align="left">zookeeper.connect</td><td align="left">无</td><td align="left">表示连接的Zookeeper集群地址，表示多个地址时用逗号分隔。并且可以配置chroot路径，即指定节点为根路径。例如：192.168.150.101:2181,192.168.150.102:2181, 192.168.150.103:2181/kafka</td></tr><tr><td align="left">zookeeper.connection.timeout.ms</td><td align="left">6000</td><td align="left">表示连接 Zookeeper 集群的超时时间。</td></tr><tr><td align="left">delete.topic.enable</td><td align="left">true</td><td align="left">表示是否开启删除主题。</td></tr></tbody></table><h3 id="4、修改配置"><a href="#4、修改配置" class="headerlink" title="4、修改配置"></a>4、修改配置</h3><h4 id="4-1、修改配置文件"><a href="#4-1、修改配置文件" class="headerlink" title="4.1、修改配置文件"></a>4.1、修改配置文件</h4><p>修改以下参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">broker.id=0</span><br><span class="line">listeners=PLAINTEXT://192.168.0.10:9092</span><br><span class="line">log.dirs=/data/kafka/data</span><br><span class="line">zookeeper.connect=192.168.150.101:2181,192.168.150.102:2181,192.168.150.103:2181/kafka</span><br></pre></td></tr></table></figure><p><strong>注意：这里只进行了简单的配置，请根据自己的业务需求进行修改。</strong></p><h4 id="4-2、创建数据目录"><a href="#4-2、创建数据目录" class="headerlink" title="4.2、创建数据目录"></a>4.2、创建数据目录</h4><p>根据配置文件中的 log.dirs 参数创建对应的目录。</p><h3 id="5、配置其他机器"><a href="#5、配置其他机器" class="headerlink" title="5、配置其他机器"></a>5、配置其他机器</h3><p>根据上面的步骤在其他两台机器上进行配置。</p><p><strong>注意：一定要根据不同服务器修改 broker.id 和 listeners 参数。</strong></p><h3 id="6、启动与关闭服务"><a href="#6、启动与关闭服务" class="headerlink" title="6、启动与关闭服务"></a>6、启动与关闭服务</h3><p>在根目录中有一个 /bin 文件夹，Kafka中所有的脚本工具都在这个目录下。</p><h4 id="6-1、启动服务"><a href="#6-1、启动服务" class="headerlink" title="6.1、启动服务"></a>6.1、启动服务</h4><p>在 kafka 根目录下执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh -daemon config/server.properties</span><br></pre></td></tr></table></figure><ul><li>-daemon： 表示指定服务后台运行。</li></ul><p><strong>注意：在启动 kafka 集群之前，要先启动 Zookeeper 集群。</strong></p><h4 id="6-2、关闭服务"><a href="#6-2、关闭服务" class="headerlink" title="6.2、关闭服务"></a>6.2、关闭服务</h4><p>在 kafka 根目录下执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-stop.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、集群规划&quot;&gt;&lt;a href=&quot;#1、集群规划&quot; class=&quot;headerlink&quot; title=&quot;1、集群规划&quot;&gt;&lt;/a&gt;1、集群规划&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;IP地址&lt;/th&gt;
&lt;th&gt;系统&lt;/th&gt;
&lt;th&gt;环境&lt;/th</summary>
      
    
    
    
    <category term="Kafka" scheme="https://blog.lee81.cn/categories/Kafka/"/>
    
    
    <category term="集群搭建" scheme="https://blog.lee81.cn/tags/%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Kafka" scheme="https://blog.lee81.cn/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper运维</title>
    <link href="https://blog.lee81.cn/2020/04/28/Zookeeper%E8%BF%90%E7%BB%B4/"/>
    <id>https://blog.lee81.cn/2020/04/28/Zookeeper%E8%BF%90%E7%BB%B4/</id>
    <published>2020-04-28T07:03:04.000Z</published>
    <updated>2022-08-29T14:09:01.573Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章摘自《从Paxos到Zookeeper分布式一致性原理与实践》</p></blockquote><h3 id="1、四字命令"><a href="#1、四字命令" class="headerlink" title="1、四字命令"></a>1、四字命令</h3><p>Zookeeper 中有很多4个英文字母长度的运维命令，简称为“四字命令”。</p><h4 id="1-1、使用方式"><a href="#1-1、使用方式" class="headerlink" title="1.1、使用方式"></a>1.1、使用方式</h4><p>四字命令的使用方式非常简单，通常有两种方式。介绍如下：</p><ul><li><p>Telnet 方式</p><p>实例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">连接</span></span><br><span class="line">telnet &lt;ip&gt; &lt;port&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入命令</span></span><br><span class="line">&lt;命令&gt;</span><br></pre></td></tr></table></figure></li><li><p>nc 方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &lt;命令&gt; | nc &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure><p>如果没有安装，请先进行安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root用户安装</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下载安装包</span></span><br><span class="line">wget http://vault.centos.org/6.6/os/x86_64/Packages/nc-1.84-22.el6.x86_64.rpm</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpm安装</span></span><br><span class="line">rpm -iUv nc-1.84-22.el6.x86_64.rpm</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2、命令介绍"><a href="#1-2、命令介绍" class="headerlink" title="1.2、命令介绍"></a>1.2、命令介绍</h4><h5 id="1-2-1、conf"><a href="#1-2-1、conf" class="headerlink" title="1.2.1、conf"></a>1.2.1、conf</h5><p>conf 命令用于输出 Zookeeper 服务器运行时使用的基本配置信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo conf | nc localhost 2181</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>clientPort</td><td>对外暴漏的客户端连接端口号。</td></tr><tr><td>dataDir</td><td>数据快照文件目录，默认情况下100000次事务操作生成一次快照。</td></tr><tr><td>dataLogDir</td><td>事务日志文件目录，生产环境中放在独立的磁盘上。</td></tr><tr><td>tickTime</td><td>服务器之间或客户端与服务器之间维持心跳的时间间隔（以毫秒为单位）。</td></tr><tr><td>maxClientCnxns</td><td>最大连接数。</td></tr><tr><td>minSessionTimeout</td><td>最小session超时 minSessionTimeout=tickTime*2</td></tr><tr><td>maxSessionTimeout</td><td>最大session超时 maxSessionTimeout=tickTime*20</td></tr><tr><td>serverId</td><td>服务器编号。</td></tr><tr><td>initLimit</td><td>集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数。</td></tr><tr><td>syncLimit</td><td>集群中的follower服务器(F)与leader服务器(L)之间 请求和应答之间能容忍的最多心跳数。</td></tr><tr><td>electionAlg</td><td>0:基于UDP的LeaderElection 1:基于UDP的FastLeaderElection 2:基于UDP和认证的FastLeaderElection 3:基于TCP的FastLeaderElection 在3.4.10版本中，默认值为3另外三种算法已经被弃用，并且有计划在之后的版本中将它们彻底删除而不再支持。</td></tr><tr><td>electionPort</td><td>选举端口。</td></tr><tr><td>quorumPort</td><td>数据通信端口。</td></tr><tr><td>peerType</td><td>是否为观察者 1为观察者。</td></tr></tbody></table><h5 id="1-2-2、cons"><a href="#1-2-2、cons" class="headerlink" title="1.2.2、cons"></a>1.2.2、cons</h5><p>cons命令用于输出当前这台服务器上所有客户端连接的详细信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo cons | nc localhost 2181</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>ip</td><td>ip地址</td></tr><tr><td>port</td><td>端口号</td></tr><tr><td>queued</td><td>等待被处理的请求数，请求缓存在队列中</td></tr><tr><td>received</td><td>收到的包数</td></tr><tr><td>sent</td><td>发送的包数</td></tr><tr><td>sid</td><td>会话id</td></tr><tr><td>lop</td><td>最后的操作 GETD-读取数据 DELE-删除数据 CREA-创建数据</td></tr><tr><td>est</td><td>连接时间戳</td></tr><tr><td>to</td><td>超时时间</td></tr><tr><td>lcxid</td><td>当前会话的操作id</td></tr><tr><td>lzxid</td><td>最大事务id</td></tr><tr><td>lresp</td><td>最后响应时间戳</td></tr><tr><td>llat</td><td>最后/最新 延时</td></tr><tr><td>minlat</td><td>最小延时</td></tr><tr><td>maxlat</td><td>最大延时</td></tr><tr><td>avglat</td><td>平均延时</td></tr></tbody></table><h5 id="1-2-3、crst"><a href="#1-2-3、crst" class="headerlink" title="1.2.3、crst"></a>1.2.3、crst</h5><p>crst 命令是一个功能性命令，用于重置所有的客户端连接统计信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo crst | nc localhost 2181</span><br></pre></td></tr></table></figure><h5 id="1-2-4、dump"><a href="#1-2-4、dump" class="headerlink" title="1.2.4、dump"></a>1.2.4、dump</h5><p>dump 命令用于输出当前集群的所有会话信息，包括这些会话的会话ID，以及每个会话创建的临时节点等信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo dump | nc localhost 2181</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>session id</td><td>znode path（1对多，处于队列中排队的session和临时节点）</td></tr></tbody></table><h5 id="1-2-5、envi"><a href="#1-2-5、envi" class="headerlink" title="1.2.5、envi"></a>1.2.5、envi</h5><p>envi 命令用于输出 Zookeeper 所在服务器运行时的环境信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo envi | nc localhost 2181</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>zookeeper.version</td><td>版本</td></tr><tr><td>host.name</td><td>host信息</td></tr><tr><td>java.version</td><td>java版本</td></tr><tr><td>java.vendor</td><td>供应商</td></tr><tr><td>java.home</td><td>运行环境所在目录</td></tr><tr><td>java.class.path</td><td>classpath</td></tr><tr><td>java.library.path</td><td>第三方库指定非java类包的位置（如：dll，so）</td></tr><tr><td>java.io.tmpdir</td><td>默认的临时文件路径</td></tr><tr><td>java.compiler</td><td>JIT 编译器的名称</td></tr><tr><td>os.name</td><td>Linux</td></tr><tr><td>os.arch</td><td>amd64</td></tr><tr><td>os.version</td><td>3.10.0-514.el7.x86_64</td></tr><tr><td>user.name</td><td>zookeeper</td></tr><tr><td>user.home</td><td>用户名目录</td></tr><tr><td>user.dir</td><td>服务所在目录</td></tr></tbody></table><h5 id="1-2-6、ruok"><a href="#1-2-6、ruok" class="headerlink" title="1.2.6、ruok"></a>1.2.6、ruok</h5><p>ruok 命令用于输出当前 Zookeeper 服务器是否正在运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo ruok | nc localhost 2181</span><br></pre></td></tr></table></figure><p>如果当前 Zookeeper 服务器正在运行，那么返回 “imok” ，否则没有任何响应输出。</p><h5 id="1-2-7、stat"><a href="#1-2-7、stat" class="headerlink" title="1.2.7、stat"></a>1.2.7、stat</h5><p>stat 命令用于获取 Zookeeper 服务器的运行时状态信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo stat | nc localhost 2181</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Zookeeper version</td><td>版本</td></tr><tr><td>Clients</td><td>客户端连接列表</td></tr><tr><td>Latency min/avg/max</td><td>延时</td></tr><tr><td>Received</td><td>收包</td></tr><tr><td>Sent</td><td>发包</td></tr><tr><td>Connections</td><td>连接数</td></tr><tr><td>Outstanding</td><td>堆积数</td></tr><tr><td>Zxid</td><td>最大事物id</td></tr><tr><td>Mode</td><td>服务器角色</td></tr><tr><td>Node</td><td>节点数</td></tr></tbody></table><h5 id="1-2-8、srvr"><a href="#1-2-8、srvr" class="headerlink" title="1.2.8、srvr"></a>1.2.8、srvr</h5><p>srvr 命令和 stat 命令的功能一致，唯一的区别是 srvr 不会将客户端的连接情况输出，仅仅输出服务器的自身信息。</p><h5 id="1-2-9、srst"><a href="#1-2-9、srst" class="headerlink" title="1.2.9、srst"></a>1.2.9、srst</h5><p>srst 命令是一个功能行命令，用于重置所有服务器的统计信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo srst | nc localhost 2181</span><br></pre></td></tr></table></figure><h5 id="1-2-10、wchs"><a href="#1-2-10、wchs" class="headerlink" title="1.2.10、wchs"></a>1.2.10、wchs</h5><p>wchs 命令用于输出当前服务器上管理的 Watcher 的概要信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo wchs | nc localhost 2181</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>connectsions</td><td>连接数</td></tr><tr><td>watch-paths</td><td>watch节点数</td></tr><tr><td>watchers</td><td>watcher数量</td></tr></tbody></table><h5 id="1-2-11、wchc"><a href="#1-2-11、wchc" class="headerlink" title="1.2.11、wchc"></a>1.2.11、wchc</h5><p>wchc 命令用于输出当前服务器上管理的 Watcher 的详细信息，以会话为单位进行归组，同时列出被该会话注册了 Watcher 的节点路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo wchc | nc localhost 2181</span><br></pre></td></tr></table></figure><p>问题:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wchc is not executed because it is not in the whitelist.</span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改启动指令 zkServer.sh </span></span><br><span class="line">​</span><br><span class="line"><span class="comment"># 注意找到这个信息</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;JMX disabled by user request&quot;</span> &gt;&amp;2</span><br><span class="line">    ZOOMAIN=<span class="string">&quot;org.apache.zookeeper.server.quorum.QuorumPeerMain&quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">​</span><br><span class="line"><span class="comment"># 下面添加如下信息</span></span><br><span class="line">ZOOMAIN=<span class="string">&quot;-Dzookeeper.4lw.commands.whitelist=* <span class="variable">$&#123;ZOOMAIN&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><h5 id="1-2-12、wchp"><a href="#1-2-12、wchp" class="headerlink" title="1.2.12、wchp"></a>1.2.12、wchp</h5><p>wchp 命令和 wchc 命令非常类似，也是用于输出当前服务器上管理的 Watcher 的详细信息，不同点在于 wchp 命令的输出信息以节点路径为单位进行归组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo wchp | nc localhost 2181</span><br></pre></td></tr></table></figure><h5 id="1-2-13、mntr"><a href="#1-2-13、mntr" class="headerlink" title="1.2.13、mntr"></a>1.2.13、mntr</h5><p>mntr 命令用于输出比 stat 命令更为详尽的服务器统计信息。</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>zk_version</td><td>版本</td></tr><tr><td>zk_avg_latency</td><td>平均延时</td></tr><tr><td>zk_max_latency</td><td>最大延时</td></tr><tr><td>zk_min_latency</td><td>最小延时</td></tr><tr><td>zk_packets_received</td><td>收包数</td></tr><tr><td>zk_packets_sent</td><td>发包数</td></tr><tr><td>zk_num_alive_connections</td><td>连接数</td></tr><tr><td>zk_outstanding_requests</td><td>堆积请求数</td></tr><tr><td>zk_server_state</td><td>leader/follower 状态</td></tr><tr><td>zk_znode_count</td><td>znode数量</td></tr><tr><td>zk_watch_count</td><td>watch数量</td></tr><tr><td>zk_ephemerals_count</td><td>临时节点（znode）</td></tr><tr><td>zk_approximate_data_size</td><td>数据大小</td></tr><tr><td>zk_open_file_descriptor_count</td><td>打开的文件描述符数量</td></tr><tr><td>zk_max_file_descriptor_count</td><td>最大文件描述符数量</td></tr><tr><td>zk_fsync_threshold_exceed_count</td><td>0</td></tr></tbody></table><h3 id="2、Zookeeper-图形化的客户端工具（ZooInspector）"><a href="#2、Zookeeper-图形化的客户端工具（ZooInspector）" class="headerlink" title="2、Zookeeper 图形化的客户端工具（ZooInspector）"></a>2、Zookeeper 图形化的客户端工具（ZooInspector）</h3><p>ZooInspector下载地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://issues.apache.org/jira/secure/attachment/12436620/ZooInspector.zip</span><br></pre></td></tr></table></figure><p>解压后进入目录ZooInspector\build，运行zookeeper-dev-ZooInspector.jar</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行命令如下</span><br><span class="line">java -jar zookeeper-dev-ZooInspector.jar</span><br></pre></td></tr></table></figure><p><img src="/%E8%BF%90%E8%A1%8C.JPG"></p><p>点击左上角连接按钮，输入zk服务地址：ip或者主机名:2181</p><p><img src="/%E8%BF%9E%E6%8E%A5.JPG"></p><p>点击OK，即可查看ZK节点信息</p><p><img src="/%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F.JPG"></p><h3 id="3、taoKeeper-监控工具"><a href="#3、taoKeeper-监控工具" class="headerlink" title="3、taoKeeper 监控工具"></a>3、taoKeeper 监控工具</h3><p>基于zookeeper的监控管理工具taokeeper，由淘宝团队开源的zk管理中间件，安装前要求服务前先配置nc 和 sshd</p><p>1.下载数据库脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/downloads/alibaba/taokeeper/taokeeper.sql</span><br></pre></td></tr></table></figure><p>2.下载主程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/downloads/alibaba/taokeeper/taokeeper-monitor.tar.gz</span><br></pre></td></tr></table></figure><p>3.下载配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/downloads/alibaba/taokeeper/taokeeper-monitor-config.properties</span><br></pre></td></tr></table></figure><p>4.配置 taokeeper-monitor-config.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#Daily</span><br><span class="line">systemInfo.envName=DAILY</span><br><span class="line">#DBCP</span><br><span class="line">dbcp.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">#mysql连接的ip地址端口号</span><br><span class="line">dbcp.dbJDBCUrl=jdbc:mysql://localhost:3306/taokeeper</span><br><span class="line">dbcp.characterEncoding=GBK</span><br><span class="line">#用户名</span><br><span class="line">dbcp.username=root</span><br><span class="line">#密码</span><br><span class="line">dbcp.password=root</span><br><span class="line">dbcp.maxActive=30</span><br><span class="line">dbcp.maxIdle=10</span><br><span class="line">dbcp.maxWait=10000</span><br><span class="line">#SystemConstant</span><br><span class="line">#用户存储内部数据的文件夹</span><br><span class="line">#创建/home/zookeeper/taokeeperdata/ZooKeeperClientThroughputStat</span><br><span class="line">SystemConstent.dataStoreBasePath=/home/zookeeper/taokeeperdata</span><br><span class="line">#ssh用户</span><br><span class="line">SystemConstant.userNameOfSSH=zookeeper</span><br><span class="line">#ssh密码</span><br><span class="line">SystemConstant.passwordOfSSH=zookeeper</span><br><span class="line">#Optional</span><br><span class="line">SystemConstant.portOfSSH=22</span><br></pre></td></tr></table></figure><p>5.安装配置 tomcat，修改catalina.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#指向配置文件所在的位置</span><br><span class="line">JAVA_OPTS=-DconfigFilePath=&quot;/home/zookeeper/taokeeper-monitor-tomcat/webapps/ROOT/conf/taokeeper-monitor-config.properties&quot;</span><br></pre></td></tr></table></figure><p>6.部署工程启动</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章摘自《从Paxos到Zookeeper分布式一致性原理与实践》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1、四字命令&quot;&gt;&lt;a href=&quot;#1、四字命令&quot; class=&quot;headerlink&quot; title=&quot;1、四字命令&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/tags/Zookeeper/"/>
    
    <category term="运维" scheme="https://blog.lee81.cn/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper一致性协议</title>
    <link href="https://blog.lee81.cn/2020/04/26/Zookeeper%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.lee81.cn/2020/04/26/Zookeeper%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-04-26T03:35:26.000Z</published>
    <updated>2022-08-29T14:08:10.490Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章摘自《从Paxos到Zookeeper分布式一致性原理与实践》</p></blockquote><h3 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h3><p>随着PC机性能的不断提升和网络技术的快速普及，很多企业开始放弃原来的大型主机，而改用小型机和普通PC服务器来搭建分布式的计算机系统。其中最为典型的就是阿里巴巴集团的 “去 IOE” 运动。</p><p> 在以前集中式的应用，我们很容易的能够实现一套满足ACID特性的事务处理系统，来保证数据的严格一致性。但在分布式的应用中，数据分散在各台不同的机器上，要想保证数据的严格一致性就很难了。因此出现了CAP和BASE这样的分布式系统经典理论。</p><h4 id="1-1、ACID"><a href="#1-1、ACID" class="headerlink" title="1.1、ACID"></a>1.1、ACID</h4><p>事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元（Unit）,狭义上的事务特指数据库事务。</p><p>事务包含四大特性，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。</p><h5 id="1-1-1、原子性"><a href="#1-1-1、原子性" class="headerlink" title="1.1.1、原子性"></a>1.1.1、原子性</h5><p>原子性是指事务必须是一个原子的操作序列单元。每一个事务的所有操作要么全部成功，要么全部失败。</p><h5 id="1-1-2、一致性"><a href="#1-1-2、一致性" class="headerlink" title="1.1.2、一致性"></a>1.1.2、一致性</h5><p>一致性是指事务的执行不能破环数据库数据的完整性和一致性。一个事务在执行之前和执行之后，数据库都必须处于一致性状态。</p><h5 id="1-1-3、隔离性"><a href="#1-1-3、隔离性" class="headerlink" title="1.1.3、隔离性"></a>1.1.3、隔离性</h5><p>隔离性是指并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。</p><h5 id="1-1-4、持久性"><a href="#1-1-4、持久性" class="headerlink" title="1.1.4、持久性"></a>1.1.4、持久性</h5><p>持久性是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。</p><h4 id="1-2、CAP定理"><a href="#1-2、CAP定理" class="headerlink" title="1.2、CAP定理"></a>1.2、CAP定理</h4><p>CAP定理是指一个分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容错性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的两项。因为分布式系统中分区容错性是一定存在的，所以主要还是在一致性和可用性中进行权衡选择。</p><p><img src="/cap.jpg"></p><h5 id="1-2-1、一致性"><a href="#1-2-1、一致性" class="headerlink" title="1.2.1、一致性"></a>1.2.1、一致性</h5><p>在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</p><p>对于一个将数据副本分布在不同分布式节点上的系统来说，如果对第一个节点的数据进行了更新操作并且更新成功后，却没有使得第二个节点上的数据得到相应的更新，于是在对第二个节点的数据进行读取操作时，获取的依然是老数据（或称为脏数据），这就是典型的分布式数据不一致情况。在分布式系统中，如果能够做到针对一个数据项的更新操作执行成功后，所有的用户都可以读取到其最新的值，那么这样的系统就被认为具有强一致性（或严格的一致性）。</p><h5 id="1-2-2、可用性"><a href="#1-2-2、可用性" class="headerlink" title="1.2.2、可用性"></a>1.2.2、可用性</h5><p>可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p><h5 id="1-2-3、分区容错性"><a href="#1-2-3、分区容错性" class="headerlink" title="1.2.3、分区容错性"></a>1.2.3、分区容错性</h5><p>分区容错性约束了一个分布式系统需要具有如下特性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p><p>网络分区是指在分布式系统中，不同的节点分布在不同的子网络（机房或异地网络等）中，由于一些特殊的原因导致这些子网络之间出现网络不连通的状况，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域。需要注意的是，组成一个分布式系统的每个节点的加入与退出都可以看作是一个特殊的网络分区。</p><h4 id="1-3、BASE理论"><a href="#1-3、BASE理论" class="headerlink" title="1.3、BASE理论"></a>1.3、BASE理论</h4><p>BASE理论是指 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的简写。是对 CAP 中一致性和可用性权衡的结果。是基于 CAP 定理逐步演化而来的，其核心思想是即使无法做到强一致性，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><h5 id="1-3-1、基本可用"><a href="#1-3-1、基本可用" class="headerlink" title="1.3.1、基本可用"></a>1.3.1、基本可用</h5><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。</p><h5 id="1-3-2、弱状态"><a href="#1-3-2、弱状态" class="headerlink" title="1.3.2、弱状态"></a>1.3.2、弱状态</h5><p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p><h5 id="1-3-3、最终一致性"><a href="#1-3-3、最终一致性" class="headerlink" title="1.3.3、最终一致性"></a>1.3.3、最终一致性</h5><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><h3 id="2、一致性协议和算法"><a href="#2、一致性协议和算法" class="headerlink" title="2、一致性协议和算法"></a>2、一致性协议和算法</h3><p>为了解决分布式一致性问题，在长期的探索研究过程中，涌现出了一大批经典的一致性协议和算法，其中最著名的就是二阶段提交协议、三阶段提交协议和Paxos算法。</p><h4 id="2-1、2PC协议"><a href="#2-1、2PC协议" class="headerlink" title="2.1、2PC协议"></a>2.1、2PC协议</h4><p>2PC，是 Two-Phase Commit 的缩写，即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理过程中能够保持原子性和一致性而设计的一种算法。</p><h5 id="2-1-1、协议说明"><a href="#2-1-1、协议说明" class="headerlink" title="2.1.1、协议说明"></a>2.1.1、协议说明</h5><p>二阶段提交协议是将事务的提交过程分成了两个阶段来进行处理。在讲述流程之前先介绍两个概念：</p><ul><li><p><strong>协调者：</strong>用来统一调度所有分布式节点的执行逻辑。</p></li><li><p><strong>参与者：</strong>被调度的分布式节点。</p></li></ul><p>其执行流程如下：</p><ul><li><p><strong>阶段一：提交事务请求</strong>（投票阶段）</p><ol><li><p>分发事务</p><p>协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p></li><li><p>执行事务</p><p>各参与者节点执行事务操作，并将Undo 和 Redo 信息记入事务日志中。</p></li><li><p>反馈响应</p><p>如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行；</p><p>如果参与者没有成功执行事务，那么就反馈给协调者 No 响应，表示事务不可以执行。</p></li></ol></li></ul><ul><li><p><strong>阶段二：执行事务请求</strong>（执行阶段）</p><p>协调者根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况下，包含以下两种可能。</p><p><strong>提交事务</strong></p><p>​    假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务提交。</p><ol><li><p>发送提交请求</p><p>协调者向所有参与者节点发出 Commit 请求。</p></li><li><p>事务提交</p><p>参与者接收到 Commit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</p></li><li><p>反馈事务提交结果</p><p>参与者在完成事务提交之后，向协调者发送Ack消息。</p></li><li><p>完成事务</p><p>协调者接收到所有参与者反馈的 Ack 消息后，完成事务。</p></li></ol><p><strong>中断事务</strong></p><p>​    假如任何一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p><ol><li><p>发送回滚请求</p><p>协调者向所有参与者节点发出 Rollback 请求。</p></li><li><p>事务回滚</p><p>参与者接收到 Rollback 请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</p></li><li><p>反馈事务回滚结果</p><p>参与者在完成事务回滚之后，向协调者发送 Ack 消息。</p></li><li><p>中断事务</p><p>协调者接收到所有参与者反馈的 Ack 消息后，完成事务中断。</p></li></ol></li></ul><h5 id="2-1-2、优缺点"><a href="#2-1-2、优缺点" class="headerlink" title="2.1.2、优缺点"></a>2.1.2、优缺点</h5><p><strong>优点：</strong></p><ul><li>原理简单</li><li>实现方便</li></ul><p><strong>缺点：</strong></p><ul><li><p>同步阻塞</p><p>二阶段提交协议存在的最明显也是最大的一个问题就是同步阻塞，这会极大地限制分布式系统的性能。在二阶段提交的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作。</p></li><li><p>单点问题</p><p>在二阶段提交中，一旦协调者出现问题，那么整个二阶段提交流程将无法运转，更为严重的是，如果协调者是在阶段二中出现问题的话，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。</p></li><li><p>数据不一致</p><p>在二阶段提交协议的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送Commit 请求之后，发生了局部网络异常或者是协调者在尚未发送完 Commit 请求之前自身发生了崩溃，导致最终只有部分参与者收到了 Commit 请求。于是，这部分收到了 Commit 请求的参与者就会进行事务的提交，而其他没有收到 Commit 请求的参与者则无法进行事务提交，于是整个分布式系统便出现了数据不一致性现象。</p></li><li><p>太过保守</p><p>二阶段提交协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。</p></li></ul><h4 id="2-2、3PC协议"><a href="#2-2、3PC协议" class="headerlink" title="2.2、3PC协议"></a>2.2、3PC协议</h4><h5 id="2-2-1、协议说明"><a href="#2-2-1、协议说明" class="headerlink" title="2.2.1、协议说明"></a>2.2.1、协议说明</h5><p>3PC，是 Three-Phase Commit 的缩写，即三阶段提交，是 2PC 的改进版，其将二阶段提交协议的“提交事务请求”过程一分为二，形成了由 CanCommit、PreCommit 和 DoCommit 三个阶段组成的事务处理协议。其执行流程如下：</p><ul><li><p><strong>阶段一：CanCommit</strong></p><ol><li><p>事务询问</p><p>协调者向所有的参与者发送一个<strong>包含事务内容的 CanCommit 请求</strong>，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p></li><li><p>反馈响应</p><p>参与者在接收到来自协调者的 CanCommit 请求后，正常情况下，如果其自身认为可以顺利执行事务，那么会反馈 Yes 响应，并进入预备状态，否则反馈 No 响应。</p></li></ol></li></ul><ul><li><p><strong>阶段二：PreCommit</strong></p><p>协调者会根据各参与者的反馈情况来决定是否可以进行事务的 PreCommit 操作，正常情况下，包含两种可能。</p><p><strong>执行事务预提交</strong></p><p>​    假如协调者从所有的参与者获得的反馈都是 Yes 响应，那么就会执行事务预提交。</p><ol><li><p>发送预提交请求</p><p>协调者向所有参与者节点发出 PreCommit 的请求，并进入 Prepared 阶段。</p></li><li><p>事务预提交</p><p> 参与者接收到 PreCommit 请求后，会执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。</p></li><li><p>反馈响应</p><p> 如果参与者成功执行了事务操作，那么就会反馈给协调者 Ack 响应，同时等待最终的指令：提交  （commit）或中止（abort）。</p></li></ol><p><strong>中断事务</strong></p><p>​    假如任何一个参与者向协调者反馈了No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p><ol><li><p>发送中断请求</p><p>协调者向所有参与者节点发出 abort 请求。</p></li><li><p>中断事务</p><p>无论是收到来自协调者的 abort 请求，或者是在等待协调者请求过程中出现超时，参与者都会中断事务。</p></li></ol></li><li><p><strong>阶段三：DoCommit</strong></p><p>该阶段将进行真正的事务提交，会存在以下两种可能的情况。</p><p><strong>执行提交</strong></p><ol><li><p>发送提交请求</p><p>进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的 Ack 响应，那么它将从 “预提交” 状态转换到 “提交” 状态，并向所有的参与者发送 doCommit 请求。</p></li><li><p>事务提交</p><p>参与者接收到 doCommit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源。</p></li><li><p>反馈事务提交结果</p><p>参与者在完成事务提交之后，向协调者发送 Ack 消息。</p></li><li><p>完成事务</p><p>协调者接收到所有参与者反馈的 Ack 消息后，完成事务。</p></li></ol><p><strong>中断事务</strong></p><p>​    进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p><ol><li><p>发送中断请求</p><p>协调者向所有的参与者节点发送 abort 请求。</p></li><li><p>事务回滚</p><p>参与者接收到 abort 请求后，会利用其在阶段二中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。</p></li><li><p>反馈事务回滚结果</p><p>参与者在完成事务回滚之后，向协调者发送 Ack 消息。</p></li><li><p>中断事务</p><p>协调者接收到所有参与者反馈的 Ack 消息后，中断事务。</p></li></ol><p>注意：阶段三可能会存在以下两种故障</p><ul><li>协调者出现问题。</li><li>协调者和参与者之间的网络出现故障。</li></ul><p>无论出现哪种情况，最终都会导致参与者无法及时接收到来自协调者的 doCommit 或是 abort 请求，针对这样的异常情况，参与者都会在等待超时之后，继续进行事务提交。</p></li></ul><h5 id="2-2-2、优缺点"><a href="#2-2-2、优缺点" class="headerlink" title="2.2.2、优缺点"></a>2.2.2、优缺点</h5><p><strong>优点：</strong></p><ul><li>相较于二阶段提交，三阶段提交降低了参与者的阻塞范围。</li><li>能够在出现单点故障后继续达成一致。</li></ul><p><strong>缺点：</strong></p><ul><li><p>数据不一致</p><p>在参与者接收到 preCommit 消息后，如果网络出现分区，此时协调者所在的节点和参与者无法进行正常的网络通信，在这种情况下，该参与者依然会进行事务的提交，这必然出现数据的不一致性。</p></li></ul><h4 id="2-3、Paxos算法"><a href="#2-3、Paxos算法" class="headerlink" title="2.3、Paxos算法"></a>2.3、Paxos算法</h4><p>Paxos 算法是一种基于消息传递且具有高度容错特性的一致性算法。是目前公认的解决分布式一致性问题最有效的算法之一。（这里不介绍Paxos算法，后面会写一篇文章专题讲讲Paxos算法）</p><h3 id="3、ZAB（Zookeeper-Atomic-Broadcast）协议"><a href="#3、ZAB（Zookeeper-Atomic-Broadcast）协议" class="headerlink" title="3、ZAB（Zookeeper Atomic Broadcast）协议"></a>3、ZAB（Zookeeper Atomic Broadcast）协议</h3><p>ZAB协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议。基于该协议，Zookeeper实现了一种主备模式的系统架构来保持集群中各副本之间数据的一致性。</p><h4 id="3-1、核心处理过程"><a href="#3-1、核心处理过程" class="headerlink" title="3.1、核心处理过程"></a>3.1、核心处理过程</h4><p>所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为 Leader 服务器，而余下的其他服务器则成为 Follower 服务器。 Leader 服务器负责将一个客户端事务请求转换成一个事务 Proposal（提议），并将该 Proposal 分发给集群中所有的 Follower 服务器。之后 Leader 服务器需要等待所有 Follower 服务器的反馈，一旦超过半数的 Follower 服务器进行了正确的反馈后，那么 Leader 就会再次向所有的 Follower 服务器分发 Commit 消息，要求其将前一个 Proposal 进行提交。</p><h4 id="3-2、协议介绍"><a href="#3-2、协议介绍" class="headerlink" title="3.2、协议介绍"></a>3.2、协议介绍</h4><p>ZAB协议包括两种基本的模式，分别是崩溃恢复和消息广播。当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断，崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步（数据同步）之后，ZAB 协议就会退出恢复模式，进入消息广播模式。Leader 服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的写事务请求，那么这些非 Leader 服务器会首先将这个事务请求转发给 Leader 服务器。<br>如果新加入了一台服务器，此服务器就会进入数据恢复模式，找到Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p><h5 id="3-2-1、崩溃恢复模式"><a href="#3-2-1、崩溃恢复模式" class="headerlink" title="3.2.1、崩溃恢复模式"></a>3.2.1、崩溃恢复模式</h5><p>当整个服务器框架启动过程中，或是当 Leader 服务器出现崩溃，或者说由于网络原因导致 Leader 服务器失去了与过半 Follower 的联系，那么就会进入崩溃恢复模式。（说白了崩溃恢复模式就是选举新的 Leader，完成数据同步）</p><p>在崩溃恢复过程中可能会出现两个数据不一致性的问题：</p><ul><li><p>ZAB 协议需要确保那些已经在 Leader服务器上<strong>提交的事务</strong>最终被所有服务器都提交。</p><p>假设一个事务在 Leader 服务器上被提交了，并且已经得到过半的 Follower 服务器的 Ack 反馈，但是在它将 Commit 消息发送给所有 Follower 机器之前，Leader 服务器挂了。针对这种情况， ZAB 协议就需要确保事务最终能够在所有的服务器上都被提交成功，否则将出现不一致。</p></li></ul><ul><li><p>ZAB 协议需要确保丢弃那些只在 Leader 服务器上<strong>被提出的事务</strong>。</p><p>假设在 Leader 服务器上 Server1 提出了一个事务之后就崩溃退出了，从而导致集群中的其他服务器都没有收到这个事务。于是，当 Server1 恢复过来再次加入到集群中的时候，ZAB 协议需要确保丢弃这个事务。</p></li></ul><p>对于上面提出的问题，决定了 ZAB 协议必须设计这样一个 Leader 选举算法：能够确保提交已经被 Leader 提交的事务 Proposal，同时丢弃已经被跳过的事务 Proposal。针对这个要求，如果让 Leader 选举算法能够保证新选举出来的 Leader 服务器拥有集群中所有机器最高编号（即 ZXID 最大）的事务 Proposal，那么就可以保证这个新选举出来的 Leader 一定具有所有已经提交的提案。更为重要的是如果让具有最高编号事务 Proposal 的机器来成为 Leader ，就可以省去 Leader 服务器检查 Proposal 的提交和丢弃工作的这一步操作了。（Leader选举过程请看 《Zookeeper深入原理》）</p><p>在完成 Leader 选举之后，正式开始工作之前，还需要确认事务日志中的所有 Proposal 是否都已经被集群中过半的机器提交了，即是否完成了数据同步。</p><p>下面介绍一下数据同步过程：</p><p>Leader服务器会为每一个 Follower服务器都准备一个队列，并将那些没有被各 Follower 服务器同步的事务以 Proposal 消息的形式逐个发送给 Follower 服务器，并在每一个 Proposal 消息后面紧接着再发送一个 Commit 消息，以表示该事务已经被提交。等到 Follower 服务器将所有其尚未同步的事务 Proposal 都从 Leader 服务器上同步过来并成功应用到本地数据库中后，Leader 服务器就会将该 Follower 服务器加入到真正的可用 Follower 列表中。</p><h5 id="3-2-2、消息广播模式"><a href="#3-2-2、消息广播模式" class="headerlink" title="3.2.2、消息广播模式"></a>3.2.2、消息广播模式</h5><p>ZAB 协议的消息广播过程使用的是一个原子广播协议，类似于一个二阶段提交的过程。但是 ZAB 协议与二阶段提交略有不同。在 ZAB 协议的二阶段提交过程中，移除了中断逻辑，所有的 Follower 服务器要么正常反馈 Leader 提出的事务 Proposal，要么就抛弃 Leader 服务器。同时 ZAB 协议支持<strong>半数原则</strong>，即超过半数的 Follower 服务器反馈 Ack 之后就开始提交事务 Proposal 了，而不需要等待集群中所有的 Follower 服务器都反馈响应。</p><p>因为这种简化的二阶段提交模型下，是无法处理 Leader 服务器崩溃退出而带来的数据不一致问题的，因此在ZAB 协议中添加了崩溃恢复模式来解决这种问题。</p><p>在消息广播过程中，Leader 服务器会为每一个事务请求生成对应的 Proposal 来进行广播，并且在广播事务 Proposal 之前，Leader 服务器会首先为这个事务 Proposal 分配一个全局单调递增的唯一ID（即 ZXID），Leader服务器会为每一个 Follower 服务器都各自分配一个单独的队列，然后将需要广播的事务 Proposal 依次放入这些队列中去，并且根据 FIFO 策略进行消息发送。每一个 Follower 服务器在接收到这个事务 Proposal 之后，都会首先将其以事务日志的形式写入到本地磁盘中去，并且在成功写入后反馈给 Leader 服务器一个 Ack 响应。当 Leader 服务器接收到超过半数 Follower 的 Ack 响应后，就会广播一个 Commit 消息给所有的 Follower 服务器以通知其进行事务提交，同时 Leader 自身也会完成对事务的提交，而每一个 Follower 服务器在接收到 Commit 消息后，也会完成对事务的提交。</p><h4 id="3-3、协议说明"><a href="#3-3、协议说明" class="headerlink" title="3.3、协议说明"></a>3.3、协议说明</h4><p>整个 ZAB 协议主要包括消息广播和崩溃恢复两个过程，进一步可以细分为三个阶段，分别是发现（Discovery）、同步（Synchronization）和广播（Broadcast）阶段。</p><p><strong>阶段一：发现</strong></p><p>主要就是 Leader 选举过程，用于在多个分布式进程中选举出主进程。</p><p><strong>阶段二：同步</strong></p><p>在完成发现流程之后，就进入了同步阶段。即 Leader 服务器和 Follower 服务器之间同步数据。</p><p><strong>阶段三：广播</strong></p><p>完成同步阶段之后，ZAB 协议就可以正式开始接收客户端新的事物请求，并进行消息广播流程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章摘自《从Paxos到Zookeeper分布式一致性原理与实践》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/tags/Zookeeper/"/>
    
    <category term="一致性协议" scheme="https://blog.lee81.cn/tags/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper使用场景</title>
    <link href="https://blog.lee81.cn/2020/04/25/Zookeeper%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://blog.lee81.cn/2020/04/25/Zookeeper%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2020-04-25T02:57:22.000Z</published>
    <updated>2022-08-29T14:07:34.105Z</updated>
    
    <content type="html"><![CDATA[<p>学 Zookeeper 就是为了用它，接下来我就介绍以下常用的使用场景。</p><h3 id="1、数据发布-订阅"><a href="#1、数据发布-订阅" class="headerlink" title="1、数据发布/订阅"></a>1、数据发布/订阅</h3><h4 id="1-1、介绍"><a href="#1-1、介绍" class="headerlink" title="1.1、介绍"></a>1.1、介绍</h4><p>数据发布/订阅，顾名思义就是发布者将数据发布到 Zookeeper 上，然后供订阅者进行数据订阅和监控，进而实现动态改变和获取数据的目的。</p><h4 id="1-2、示例"><a href="#1-2、示例" class="headerlink" title="1.2、示例"></a>1.2、示例</h4><p><strong>需求：</strong>当我们部署集群时，需要重复修改每个节点的配置信息，节点少的时候还好，如果多了，并且需要修改频繁的时候就会很浪费时间。此时以数据库连接信息为例，连接信息包括：IP地址，端口号，用户名，密码，数据库名称。</p><p><strong>解决：</strong> 为解决上述需求，我们可以引入 Zookeeper 作为配置中心，将所有的配置信息都发布到 Zookeeper 上，然后供集群所有节点进行数据订阅和监控，当需要修改配置时，只需修改 Zookeeper 上的数据，就可以触发所有节点进行修改。</p><p><img src="/%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png"></p><p>设计思路如下：</p><ol><li>创建一个永久节点（mysql）表示为数据库连接信息。</li><li>在 mysql 节点下创建多个子节点，表示IP地址，端口号，用户名，密码，数据库名称。</li><li>所有的客户端都获取 mysql 节点下的子节点信息，并注册监控事件。</li><li>当数据库连接信息有变化时，所有客户端都能被触发，重新执行步骤3。</li></ol><h3 id="2、Master选举"><a href="#2、Master选举" class="headerlink" title="2、Master选举"></a>2、Master选举</h3><h4 id="2-1、介绍"><a href="#2-1、介绍" class="headerlink" title="2.1、介绍"></a>2.1、介绍</h4><p>Master 选举就是从集群中选出一个所谓的 “老大”，这里称之为 Master，Master 往往用来协调集群中其他系统单元，具有对分布式系统状态变更的决定权。</p><h4 id="2-2、示例"><a href="#2-2、示例" class="headerlink" title="2.2、示例"></a>2.2、示例</h4><p><strong>需求：</strong>需要从集群选出一个节点作为主节点 (Master)，来处理工作，其他节点作为从节点，当主节点挂掉时，其他节点接着竞选主节点。</p><p><strong>解决：</strong> 为解决上述需求，我们可以引入 Zookeeper 服务，通过所有节点竞争创建同一个节点（Master），创建成功的为主节点，其他节点只能监控 Master 节点，当 Master 节点被删除时，接着去竞争创建。</p><p><img src="/Master%E9%80%89%E4%B8%BE.png"></p><p>设计思路如下：</p><ol><li>创建一个永久节点（App1）表示为App1集群。</li><li>集群中的所有节点都竞争创建名为 Master 的临时节点（这里设计为临时节点的原因是当主节点宕机时，临时节点也就跟着被删除了）。</li><li>创建成功 Master 节点的集群节点就是主节点，处理功能，当然还可以将主节点的一些本地信息存储到 Master 节点中，供监控系统展示主节点信息。</li><li>其他集群节点就对 Master 节点注册监控。</li><li>当Master 节点删除时，其他节点都收到通知，重新执行步骤2。</li></ol><h3 id="3、分布式锁"><a href="#3、分布式锁" class="headerlink" title="3、分布式锁"></a>3、分布式锁</h3><h4 id="3-1、介绍"><a href="#3-1、介绍" class="headerlink" title="3.1、介绍"></a>3.1、介绍</h4><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。比如你的项目为单体应用是，就可以使用Synchronize 或者 Lock 锁来实现同步访问共享资源。但是如果是分布式应用，多个应用之间如果想同步访问共享资源时 Synchronize 和 Lock 就不管用了，所以就提出了分布式锁的概念。现在实现分布式锁的方式有很多种，比如：Redis，数据库，Zookeeper。这里只说 Zookeeper 实现分布式锁的思路。</p><h4 id="3-2、示例"><a href="#3-2、示例" class="headerlink" title="3.2、示例"></a>3.2、示例</h4><p><strong>需求：</strong>当一个分布式系统中，需要同步访问共享某一个资源时，怎么才能防止并发问题呢？</p><p><strong>解决：</strong>如果理解了上面的 Master 选举的思想，应该就明白 Zookeeper 怎么实现分布式锁了（创建指定节点，创建成功的线程就是获取到锁）。但是如果使用上面的方式实现的话有一个问题，如果现在有成千上百个线程同时获取分布式锁时，就会出现<strong>羊群效应</strong>。</p><p><strong>羊群效应：</strong>当并发量比较高时，当线程释放锁时，其他所有的线程都需要抢占锁（即创建锁节点），就会出现大量的创建请求，所以就出现了羊群效应。如何解决羊群效应呢？请看下图：</p><p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.png"></p><p>设计思路如下：</p><ol><li>当线程需要获取锁时，就创建一个节点路径为 lock 的临时有序节点（使用临时节点是为了防止死锁的问题）。</li><li>获取 /MyLock 的子节点列表。</li><li>判断自己创建的节点是否为第一个。</li><li>如果是第一个，说明获取到了锁，执行业务代码。</li><li>如果不是第一个，就对自己的前一个节点注册监控，当前一个节点删除时，就重新执行步骤2。</li><li>当执行完业务代码时，删除自己创建的节点。</li></ol><p>这样每次释放锁，就不会让其他所有线程都去抢占锁，只需要让下一个节点去抢占锁就可以了。避免了羊群效应。</p><p><strong>注意：上面讲述的是排他锁，只有一个线程能获取到锁。如果想实现读写锁，该怎么进行变形呢？自己可以尝试思考一下。</strong></p><h3 id="4、分布式唯一性ID"><a href="#4、分布式唯一性ID" class="headerlink" title="4、分布式唯一性ID"></a>4、分布式唯一性ID</h3><h4 id="4-1、介绍"><a href="#4-1、介绍" class="headerlink" title="4.1、介绍"></a>4.1、介绍</h4><p>在过去的单库单表型系统中，通常可以使用数据库字段自带的auto_increment属性来自动为每条记录生成一个唯一的ID。但是分库分表后，就无法在依靠数据库的auto_increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一ID。</p><h4 id="4-2、示例"><a href="#4-2、示例" class="headerlink" title="4.2、示例"></a>4.2、示例</h4><p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%94%AF%E4%B8%80%E6%80%A7ID.png"></p><p>设计思路如下：</p><ol><li>当需要生成唯一性ID 时，就在 /MyID 节点下创建一个节点路径为 id 的持久有序节点。</li><li>获取创建后的节点路径。</li><li>将节点路径的前缀 id 截取，留下的就是唯一性 ID。</li><li>然后删除比自己小的节点。</li></ol><p><strong>也可以使用 /MyID 中的版本号来实现 唯一性 ID。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学 Zookeeper 就是为了用它，接下来我就介绍以下常用的使用场景。&lt;/p&gt;
&lt;h3 id=&quot;1、数据发布-订阅&quot;&gt;&lt;a href=&quot;#1、数据发布-订阅&quot; class=&quot;headerlink&quot; title=&quot;1、数据发布/订阅&quot;&gt;&lt;/a&gt;1、数据发布/订阅&lt;/h3&gt;&lt;</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/tags/Zookeeper/"/>
    
    <category term="使用场景" scheme="https://blog.lee81.cn/tags/%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper深入原理</title>
    <link href="https://blog.lee81.cn/2020/04/18/Zookeeper%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.lee81.cn/2020/04/18/Zookeeper%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86/</id>
    <published>2020-04-18T06:50:30.000Z</published>
    <updated>2022-08-28T07:41:59.507Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章摘自《从Paxos到Zookeeper分布式一致性原理与实践》</p></blockquote><h3 id="1、系统模型"><a href="#1、系统模型" class="headerlink" title="1、系统模型"></a>1、系统模型</h3><h4 id="1-1、数据模型"><a href="#1-1、数据模型" class="headerlink" title="1.1、数据模型"></a>1.1、数据模型</h4><p>Zookeeper 的视图结构是一个树形结构，树上的每个节点称之为数据节点（即 ZNode），每个ZNode 上都可以保存数据，同时还可以挂载子节点。并且Zookeeper的根节点为 “/“。</p><p><img src="/zookeeper%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><h4 id="1-2、节点类型"><a href="#1-2、节点类型" class="headerlink" title="1.2、节点类型"></a>1.2、节点类型</h4><p>在 Zookeeper 中，每个数据节点都是有生命周期的，其生命周期的长短取决于数据节点的节点类型。在 Zookeeper 中有如下几类节点：</p><table><thead><tr><th>节点类型</th><th>说明</th></tr></thead><tbody><tr><td>持久节点（PERSISTENT）</td><td>指该数据节点被创建后，就会一直存在于 Zookeeper 服务器上，直到有删除操作来主动清除这个节点。</td></tr><tr><td>持久顺序节点（PERSISTENT_SEQUENTIAL）</td><td>基本特性和持久节点是一致的，额外的特性表现在顺序性上，在 Zookeeper 中，每个父节点都会为它的第一级子节点维护一份顺序，用于记录下每个子节点创建的先后顺序。基于这个顺序特性，在创建子节点的时候，可以设置这个标记，那么在创建节点过程中，Zookeeper 会自动为给定节点名加上一个数字后缀，作为一个新的、完整的节点名。<strong>另外需要注意的是，这个数字后缀的上限是整型的最大值。</strong></td></tr><tr><td>临时节点（EPHEMERAL）</td><td>临时节点的生命周期和客户端的会话绑定在一起，如果客户端会话失效，那么这个节点就会被自动清理掉。<strong>另外，Zookeeper 规定了不能基于临时节点来创建子节点，即临时节点只能作为叶子节点。</strong></td></tr><tr><td>临时顺序节点（EPHEMERAL_SEQUENTIAL）</td><td>基本特性和临时节点一致，只是添加了顺序的特性。</td></tr></tbody></table><h4 id="1-3、状态信息"><a href="#1-3、状态信息" class="headerlink" title="1.3、状态信息"></a>1.3、状态信息</h4><p>每个数据节点中除了存储了数据内容之外，还存储了数据节点本身的一些状态信息（State）。</p><table><thead><tr><th>状态属性</th><th>说明</th></tr></thead><tbody><tr><td>cZxid</td><td>即 Create ZXID，表示该数据节点被创建时的事务ID。</td></tr><tr><td>ctime</td><td>即 Create Time，表示该数据节点被创建的时间。</td></tr><tr><td>mZxid</td><td>即 Modified ZXID，表示该节点最后一次被更新时的事务ID。</td></tr><tr><td>mtime</td><td>即 Modified Time，表示该数据节点最后一次被更新的时间。</td></tr><tr><td>pZxid</td><td>表示该节点的子节点列表最后一次被修改时的事务ID。注意，只有子节点列表变更了才会变更 pZxid，子节点内容变更不会影响pZxid。</td></tr><tr><td>cversion</td><td>表示子节点的版本号。</td></tr><tr><td>dataVersion</td><td>表示数据节点的版本号。</td></tr><tr><td>aclVersion</td><td>表示节点的 ACL 版本号。</td></tr><tr><td>ephemeralOwner</td><td>创建该临时节点的会话的sessionID。如果该节点是持久节点，那么这个属性值为0。</td></tr><tr><td>dataLength</td><td>表示数据内容的长度。</td></tr><tr><td>numChildren</td><td>表示当前节点的子节点个数。</td></tr></tbody></table><h4 id="1-4、ZXID"><a href="#1-4、ZXID" class="headerlink" title="1.4、ZXID"></a>1.4、ZXID</h4><p>在Zookeeper 中，事务是指能够改变 Zookeeper 服务器状态的操作，我们也称之为事务操作或更新操作，一般包括数据节点创建与删除、数据节点内容更新和客户端会话创建与失效等操作。对于每一个事务请求，Zookeeper 都会为其分配一个全局唯一的事务ID，用 ZXID 来表示，通常是一个 64 位的数字。每一个 ZXID 对应一次更新操作，从这些 ZXID 中可以间接地识别出 Zookeeper 处理这些更新操作请求的全局顺序。</p><p>ZXID 是一个 64 位的数字，其中低 32 位可以看作是一个简单的单调递增的计数器，针对客户端的每一个事务请求，Leader 服务器在产生一个新的事务 Proposal 的时候，都会对该计数器进行加 1 操作；而高 32 位则代表了 Leader 周期 epoch 的编号，每当选举产生一个新的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务 Proposal 的 ZXID，并从该 ZXID 中解析出对应的 epoch 值，然后再对其进行加 1 操作，之后就会以此编号作为新的 epoch，并将低 32 位置 0 来开始生成新的 ZXID。</p><h4 id="1-5、版本"><a href="#1-5、版本" class="headerlink" title="1.5、版本"></a>1.5、版本</h4><p> Zookeeper 中为数据节点引入了版本的概念，每个数据节点都具有三种类型的版本信息（在上面的状态信息中已经介绍了三种版本信息代表的意思），对数据节点的任何更新操作都会引起版本号的变化。其中我们以 dataVersion 为例来说明。在一个数据节点被创建完毕之后，节点的dataVersion 值是 0，表示的含义是 ”当前节点自从创建之后，被更新过 0 次“。如果现在对该节点的数据内容进行更新操作，那么随后，dataVersion 的值就会变成 1。即表示的是对数据节点的数据内容的变更次数。</p><p>版本的作用是用来实现乐观锁机制中的 “写入校验” 的。例如，当要修改数据节点的数据内容时，带上版本号，如果数据节点的版本号与传入的版本号相等，就进行修改，否则修改失败。</p><h4 id="1-6、Watcher"><a href="#1-6、Watcher" class="headerlink" title="1.6、Watcher"></a>1.6、Watcher</h4><h5 id="1-6-1、概述"><a href="#1-6-1、概述" class="headerlink" title="1.6.1、概述"></a>1.6.1、概述</h5><p>Zookeeper 提供了分布式数据的发布/订阅功能。一个典型的发布/订阅模型系统定义了一种一对多的订阅关系，能够让多个订阅者同时监听某一个主题对象，当这个主题对象自身状态变化时，会通知所有订阅者，使它们能够做出相应的处理。在 Zookeeper 中，引入了 Watcher 机制来实现这种分布式的通知功能。Zookeeper 允许客户端向服务端注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，那么就会向指定客户端发送一个事件通知来实现分布式的通知功能。</p><p><img src="/Watcher.png"></p><p>从上图可以看出 Zookeeper 的 Watcher 机制主要包括客户端线程、客户端WatchMananger 和 Zookeeper 服务器三部分。在具体工作流程上，简单地讲，客户端在向 Zookeeper 服务器注册 Watcher 的同时，会将 Watcher 对象存储在客户端的 WatchMananger 中。当 Zookeeper 服务器端触发 Watcher 事件后，会向客户端发送通知，客户端线程从 WatchManager 中取出对应的 Watcher 对象来执行回调逻辑。</p><h5 id="1-6-2、Watcher特性"><a href="#1-6-2、Watcher特性" class="headerlink" title="1.6.2、Watcher特性"></a>1.6.2、Watcher特性</h5><ul><li><strong>一次性：</strong>表示无论是服务端还是客户端，一旦一个 Watcher 被触发，Zookeeper 都会将其从相应的存储中移除。因此，开发人员在 Watcher 的使用上要记住的一点是需要反复注册。</li><li><strong>客户端串行执行：</strong>客户端 Watcher 回调的过程是一个串行同步的过程，这为我们保证了顺序，同时，需要开发人员注意的一点是，千万不要因为一个 Watcher 的处理逻辑影响了整个客户端的 Watcher 回调。</li><li><strong>轻量：</strong>WatchedEvent 是 Zookeeper 整个 Watcher 通知机制的最小通知单元，这个数据结构中只包含三部分内容：通知状态、事件类型和节点路径。也就是说，Watcher通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</li></ul><h5 id="1-6-3、watcher接口设计"><a href="#1-6-3、watcher接口设计" class="headerlink" title="1.6.3、watcher接口设计"></a>1.6.3、watcher接口设计</h5><p>Watcher是一个接口，任何实现了Watcher接口的类就是一个新的Watcher。Watcher内部包含了两个枚举类：KeeperState、EventType</p><ul><li><p><strong>Watcher通知状态(KeeperState)</strong></p><p>KeeperState是客户端与服务端连接状态发生变化时对应的通知类型。路径为org.apache.zookeeper.Watcher.Event.KeeperState，是一个枚举类，其枚举属性如下：</p></li></ul><table><thead><tr><th>枚举属性</th><th>说明</th></tr></thead><tbody><tr><td>SyncConnected</td><td>客户端与服务器正常连接时</td></tr><tr><td>Disconnected</td><td>客户端与服务器断开连接时</td></tr><tr><td>Expired</td><td>会话session失效时</td></tr><tr><td>AuthFailed</td><td>身份认证失败时</td></tr></tbody></table><ul><li><p><strong>Watcher事件类型(EventType)</strong></p><p>EventType是数据节点(znode)发生变化时对应的通知类型。EventType变化时KeeperState永远处于SyncConnected通知状态下；当KeeperState发生变化时，EventType永远为None。其路径为org.apache.zookeeper.Watcher.Event.EventType，是一个枚举类，枚举属性如下：</p></li></ul><table><thead><tr><th>枚举属性</th><th>说明</th></tr></thead><tbody><tr><td>None</td><td>无</td></tr><tr><td>NodeCreated</td><td>Watcher监听的数据节点被创建时</td></tr><tr><td>NodeDeleted</td><td>Watcher监听的数据节点被删除时</td></tr><tr><td>NodeDataChanged</td><td>Watcher监听的数据节点内容发生变更时(无论内容数据是否变化)</td></tr><tr><td>NodeChildrenChanged</td><td>Watcher监听的数据节点的子节点列表发生变更时</td></tr></tbody></table><p><strong>注</strong>：客户端接收到的相关事件通知中只包含状态及类型等信息，不包括节点变化前后的具体内容，变化前的数据需业务自身存储，变化后的数据需调用get等方法重新获取；</p><h5 id="1-6-4、捕获相应的事件"><a href="#1-6-4、捕获相应的事件" class="headerlink" title="1.6.4、捕获相应的事件"></a>1.6.4、捕获相应的事件</h5><p>上面讲到zookeeper客户端连接的状态和zookeeper对znode节点监听的事件类型，下面我们来讲解如何建立zookeeper的watcher监听。在zookeeper中采用zk.getChildren(path, watch)、zk.exists(path, watch)、zk.getData(path, watcher, stat)这样的方式为某个znode注册监听。</p><p>下表以node-x节点为例，说明调用的注册方法和可监听事件间的关系：</p><table><thead><tr><th align="left">注册方式</th><th align="left">Created</th><th align="left">ChildrenChanged</th><th align="left">Changed</th><th align="left">Deleted</th></tr></thead><tbody><tr><td align="left">zk.exists(“/node-x”,watcher)</td><td align="left">可监控</td><td align="left"></td><td align="left">可监控</td><td align="left">可监控</td></tr><tr><td align="left">zk.getData(“/node-x”,watcher)</td><td align="left"></td><td align="left"></td><td align="left">可监控</td><td align="left">可监控</td></tr><tr><td align="left">zk.getChildren(“/node-x”,watcher)</td><td align="left"></td><td align="left">可监控</td><td align="left"></td><td align="left">可监控</td></tr></tbody></table><h4 id="1-7、ACL"><a href="#1-7、ACL" class="headerlink" title="1.7、ACL"></a>1.7、ACL</h4><p>Zookeeper 中提供了一套完善的 ACL（Access Control List）权限控制机制来保障数据的安全。</p><h5 id="1-7-1、概述"><a href="#1-7-1、概述" class="headerlink" title="1.7.1、概述"></a>1.7.1、概述</h5><p>ACL 由三部分组成，分别是：权限模式（Scheme）、授权对象（ID）和权限（Permission），通常使用“scheme: ​id:permission”来标识一个有效的ACL 信息。下面分别介绍：</p><ol><li><p><strong>权限模式（Scheme）</strong></p><table><thead><tr><th>方案</th><th>说明</th></tr></thead><tbody><tr><td>world</td><td>只有一个用户：anyone，代表登录 Zookeeper 所有人（默认）</td></tr><tr><td>ip</td><td>对客户端使用IP地址认证。</td></tr><tr><td>auth</td><td>使用已添加认证的用户认证。</td></tr><tr><td>digest</td><td>使用“用户名:密码”方式认证。</td></tr></tbody></table></li><li><p><strong>授权对象（ID）</strong></p><p>授权对象ID是指，权限赋予的实体，例如：IP 地址或用户。</p></li><li><p><strong>权限（Permission）</strong></p><table><thead><tr><th>权限</th><th>ACL简写</th><th>描述</th></tr></thead><tbody><tr><td>create</td><td>c</td><td>可以创建子节点。</td></tr><tr><td>delete</td><td>d</td><td>可以删除子节点（仅下一级节点）。</td></tr><tr><td>read</td><td>r</td><td>可以读取节点数据或子节点列表。</td></tr><tr><td>write</td><td>w</td><td>可以对节点进行更新操作。</td></tr><tr><td>admin</td><td>a</td><td>可以设置节点访问控制列表权限。</td></tr></tbody></table></li></ol><h5 id="1-7-2、特性"><a href="#1-7-2、特性" class="headerlink" title="1.7.2、特性"></a>1.7.2、特性</h5><ul><li>zooKeeper的权限控制是基于每个znode节点的，需要对每个节点设置权限。</li><li>每个znode支持设置多种权限控制方案和多个权限。</li><li>子节点不会继承父节点的权限，客户端无权访问某节点，但可能可以访问它的子节点。</li></ul><h5 id="1-7-3、案例"><a href="#1-7-3、案例" class="headerlink" title="1.7.3、案例"></a>1.7.3、案例</h5><ul><li><p>world授权模式</p><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl &lt;path&gt; world:anyone:&lt;acl&gt;</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 0] create /node1 &quot;node1&quot;</span><br><span class="line">Created /node1</span><br><span class="line">[zk: localhost:2181(CONNECTED) 1] getAcl /node1</span><br><span class="line">&#x27;world,&#x27;anyone</span><br><span class="line">: cdrwa</span><br><span class="line">[zk: localhost:2181(CONNECTED) 2] setAcl /node1 world:anyone:crwa</span><br><span class="line">cZxid = 0x100000004</span><br><span class="line">ctime = Fri May 29 14:31:54 CST 2020</span><br><span class="line">mZxid = 0x100000004</span><br><span class="line">mtime = Fri May 29 14:31:54 CST 2020</span><br><span class="line">pZxid = 0x100000004</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure></li><li><p>IP授权模式</p><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl &lt;path&gt; ip:&lt;ip&gt;:&lt;acl&gt;</span><br></pre></td></tr></table></figure><p>案例</p><p>注意：远程登录zookeeper命令:./zkCli.sh -server ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 18] create /node2 &quot;node2&quot;</span><br><span class="line">Created /node2</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 23] setAcl /node2 ip:192.168.150.101:cdrwa</span><br><span class="line">cZxid = 0xe</span><br><span class="line">ctime = Fri Dec 13 22:30:29 CST 2019</span><br><span class="line">mZxid = 0x10</span><br><span class="line">mtime = Fri Dec 13 22:33:36 CST 2019</span><br><span class="line">pZxid = 0xe</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 2</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 20</span><br><span class="line">numChildren = 0</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 25] getAcl /node2</span><br><span class="line">&#x27;ip,&#x27;192.168.150.101</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line">#使用IP非 192.168.150.101 的机器</span><br><span class="line">[zk: localhost:2181(CONNECTED) 0] get /node2</span><br><span class="line">Authentication is not valid : /node2 #没有权限</span><br></pre></td></tr></table></figure></li><li><p>Auth授权模式</p><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addauth digest &lt;user&gt;:&lt;password&gt; #添加认证用户</span><br><span class="line">setAcl &lt;path&gt; auth:&lt;user&gt;:&lt;acl&gt;</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 6] create /node3 &quot;node3&quot;</span><br><span class="line">Created /node3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加认证用户</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 7] addauth digest ld:123456</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 8] setAcl /node3 auth:ld:cdrwa</span><br><span class="line">cZxid = 0x10000000c</span><br><span class="line">ctime = Fri May 29 14:47:13 CST 2020</span><br><span class="line">mZxid = 0x10000000c</span><br><span class="line">mtime = Fri May 29 14:47:13 CST 2020</span><br><span class="line">pZxid = 0x10000000c</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 9] getAcl /node3</span><br><span class="line">&#x27;digest,&#x27;ld:kesl2p6Yx58a+/mP+TKSFZkzkZ0=</span><br><span class="line">: cdrwa</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加认证用户后可以访问</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 10] get /node3</span><br><span class="line">node3</span><br><span class="line">cZxid = 0x10000000c</span><br><span class="line">ctime = Fri May 29 14:47:13 CST 2020</span><br><span class="line">mZxid = 0x10000000c</span><br><span class="line">mtime = Fri May 29 14:47:13 CST 2020</span><br><span class="line">pZxid = 0x10000000c</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure></li><li><p>Digest授权模式</p><p>命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl &lt;path&gt; digest:&lt;user&gt;:&lt;password&gt;:&lt;acl&gt;</span><br></pre></td></tr></table></figure><p>这里的密码是经过SHA1及BASE64处理的密文，在SHELL中可以通过以下命令计算：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64</span><br></pre></td></tr></table></figure><p>先来计算一个密文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n monkey:123456 | openssl dgst -binary -sha1 | openssl base64</span><br></pre></td></tr></table></figure><p>案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 12] create /node4 &quot;node4&quot;</span><br><span class="line">Created /node4</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 13] setAcl /node4 digest:monkey:Rk6u/zJJdOYrTZ6+J0p4/4gTILg=:cdrwa</span><br><span class="line">cZxid = 0x10000000e</span><br><span class="line">ctime = Fri May 29 14:52:50 CST 2020</span><br><span class="line">mZxid = 0x10000000e</span><br><span class="line">mtime = Fri May 29 14:52:50 CST 2020</span><br><span class="line">pZxid = 0x10000000e</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">没有权限无法读取</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 14] getAcl /node4</span><br><span class="line">Authentication is not valid : /node4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加认证用户</span></span><br><span class="line">[zk: localhost:2181(CONNECTED) 15] addauth digest monkey:123456</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 16] getAcl /node4               </span><br><span class="line">&#x27;digest,&#x27;monkey:Rk6u/zJJdOYrTZ6+J0p4/4gTILg=</span><br><span class="line">: cdrwa</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 17] get /node4</span><br><span class="line">node4</span><br><span class="line">cZxid = 0x10000000e</span><br><span class="line">ctime = Fri May 29 14:52:50 CST 2020</span><br><span class="line">mZxid = 0x10000000e</span><br><span class="line">mtime = Fri May 29 14:52:50 CST 2020</span><br><span class="line">pZxid = 0x10000000e</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure></li><li><p>多种模式授权</p><p>同一个节点可以同时使用多种模式授权</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 18] create /node5 &quot;node5&quot;</span><br><span class="line">Created /node5</span><br><span class="line">[zk: localhost:2181(CONNECTED) 19] addauth digest ld:123456</span><br><span class="line">[zk: localhost:2181(CONNECTED) 20] setAcl /node5 ip:192.168.150.101:cdrwa,auth:ld:cdrwa</span><br><span class="line">cZxid = 0x100000010</span><br><span class="line">ctime = Fri May 29 14:56:38 CST 2020</span><br><span class="line">mZxid = 0x100000010</span><br><span class="line">mtime = Fri May 29 14:56:38 CST 2020</span><br><span class="line">pZxid = 0x100000010</span><br><span class="line">cversion = 0</span><br><span class="line">dataVersion = 0</span><br><span class="line">aclVersion = 1</span><br><span class="line">ephemeralOwner = 0x0</span><br><span class="line">dataLength = 5</span><br><span class="line">numChildren = 0</span><br></pre></td></tr></table></figure></li></ul><h5 id="1-7-4、ACL-超级管理员"><a href="#1-7-4、ACL-超级管理员" class="headerlink" title="1.7.4、ACL 超级管理员"></a>1.7.4、ACL 超级管理员</h5><p>zookeeper的权限管理模式有一种叫做super，该模式提供一个超管可以方便的访问任何权限的节点</p><p>假设这个超管是：super:admin，需要先为超管生成密码的密文</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -n super:admin | openssl dgst -binary -sha1 | openssl base64</span><br></pre></td></tr></table></figure><p>那么打开zookeeper目录下的/bin/zkServer.sh服务器脚本文件，找到如下一行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="variable">$JAVA</span> <span class="string">&quot;-Dzookeeper.log.dir=<span class="variable">$&#123;ZOO_LOG_DIR&#125;</span>&quot;</span> <span class="string">&quot;-Dzookeeper.root.logger=<span class="variable">$&#123;ZOO_LOG4J_PROP&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>这就是脚本中启动zookeeper的命令，默认只有以上两个配置项，我们需要加一个超管的配置项</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=&quot;</span></span><br></pre></td></tr></table></figure><p>那么修改以后这条完整命令变成了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nohup</span> <span class="variable">$JAVA</span> <span class="string">&quot;-Dzookeeper.log.dir=<span class="variable">$&#123;ZOO_LOG_DIR&#125;</span>&quot;</span> <span class="string">&quot;-Dzookeeper.root.logger=<span class="variable">$&#123;ZOO_LOG4J_PROP&#125;</span>&quot;</span> <span class="string">&quot;-Dzookeeper.DigestAuthenticationProvider.superDigest=super:xQJmxLMiHGwaqBvst5y6rkB6HQs=&quot;</span>\</span><br><span class="line">    -<span class="built_in">cp</span> <span class="string">&quot;<span class="variable">$CLASSPATH</span>&quot;</span> <span class="variable">$JVMFLAGS</span> <span class="variable">$ZOOMAIN</span> <span class="string">&quot;<span class="variable">$ZOOCFG</span>&quot;</span> &gt; <span class="string">&quot;<span class="variable">$_ZOO_DAEMON_OUT</span>&quot;</span> 2&gt;&amp;1 &lt; /dev/null &amp;</span><br></pre></td></tr></table></figure><p>之后启动zookeeper,输入如下命令添加权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addauth digest super:admin #添加认证用户</span><br></pre></td></tr></table></figure><h3 id="2、Leader-选举"><a href="#2、Leader-选举" class="headerlink" title="2、Leader 选举"></a>2、Leader 选举</h3><h4 id="2-1、服务器状态"><a href="#2-1、服务器状态" class="headerlink" title="2.1、服务器状态"></a>2.1、服务器状态</h4><ul><li>looking：寻找leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入 Leader 选举流程。</li><li>leading：领导者状态。表明当前服务器角色是leader。</li><li>following：跟随者状态。表明当前服务器角色是follower。</li><li>observing：观察者状态。表明当前服务器角色是observer。</li></ul><h4 id="2-2、服务器启动时期的-Leader-选举"><a href="#2-2、服务器启动时期的-Leader-选举" class="headerlink" title="2.2、服务器启动时期的 Leader 选举"></a>2.2、服务器启动时期的 Leader 选举</h4><p>在服务器集群初始化阶段，我们以 3 台机器组成的服务器集群为例，当有一台服务器server1 启动的时候，它是无法进行 Leader 选举的，当第二台机器 server2 也启动时，此时这两台服务器已经能够进行互相通信，每台机器都试图找到一个 Leader，于是便进入了 Leader 选举流程。</p><ol><li><p>每个server发出一个投票。由于是初始情况，server1和server2都会将自己作为leader服务器来进行投票，每次投票会包含所推举的服务器的myid和zxid，使用(myid, zxid)来表示，此时server1的投票为(1, 0)，server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。</p></li><li><p>集群中的每台服务器接收来自集群中各个服务器的投票。</p></li><li><p>处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行pk，pk规则如下</p><ul><li>优先检查zxid。zxid比较大的服务器优先作为leader。</li><li>如果zxid相同，那么就比较myid。myid较大的服务器作为leader服务器。</li></ul><p>​       对于Server1而言，它的投票是(1, 0)，接收Server2的投票为(2, 0)，首先会比较两者的zxid，均为0，再比较myid，此时server2的myid最大，于是更新自己的投票为(2, 0)，然后重新投票，对于server2而言，其无须更新自己的投票，只是再次向集群中所有机器发出上一次投票信息即可。</p></li><li><p>统计投票。每次投票后，服务器都会统计投票信息，判断是否已经有过半机器接受到相同的投票信息，对于server1、server2而言，都统计出集群中已经有两台机器接受了(2, 0)的投票信息，此时便认为已经选出了leader。</p></li><li><p>改变服务器状态。一旦确定了leader，每个服务器就会更新自己的状态，如果是follower，那么就变更为following，如果是leader，就变更为leading。</p></li></ol><h4 id="2-3、服务器运行时期的-Leader-选举"><a href="#2-3、服务器运行时期的-Leader-选举" class="headerlink" title="2.3、服务器运行时期的 Leader 选举"></a>2.3、服务器运行时期的 Leader 选举</h4><p>在zookeeper运行期间，leader与非leader服务器各司其职，即便当有非leader服务器宕机或新加入，此时也不会影响leader，但是一旦leader服务器挂了，那么整个集群将暂停对外服务，进入新一轮leader选举，其过程和启动时期的Leader选举过程基本一致。</p><p>假设正在运行的有server1、server2、server3三台服务器，当前leader是server2，若某一时刻leader挂了，此时便开始Leader选举。选举过程如下:</p><ol><li>变更状态。leader挂后，余下的非 Observer 服务器都会将自己的服务器状态变更为looking，然后开始进入leader选举过程。</li><li>每个server会发出一个投票。在运行期间，每个服务器上的zxid可能不同，此时假定server1的zxid为123，server3的zxid为122，在第一轮投票中，server1和server3都会投自己，产生投票(1, 123)，(3, 122)，然后各自将投票发送给集群中所有机器。</li><li>接收来自各个服务器的投票。</li><li>处理投票。对于投票的处理，和上面提到的服务器启动期间的处理规则是一致的。在这个例子里面，由于 Server1 的 zxid 为 123，Server3 的 zxid 为 122，那么显然，Server1 会成为 Leader。</li><li>统计投票。</li><li>改变服务器状态。</li></ol><h4 id="2-4、Observer-角色及其设置"><a href="#2-4、Observer-角色及其设置" class="headerlink" title="2.4、Observer 角色及其设置"></a>2.4、Observer 角色及其设置</h4><p>observer角色特点：</p><ol><li>不参与集群的leader选举</li><li>不参与集群中写数据时的ack反馈</li></ol><p>为了使用observer角色，在任何想变成observer角色的配置文件中加入如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peerType=observer</span><br></pre></td></tr></table></figure><p>并在所有server的配置文件中，配置成observer模式的server的那行配置追加:observer，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.3=192.168.60.130:2289:3389:observer</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章摘自《从Paxos到Zookeeper分布式一致性原理与实践》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1、系统模型&quot;&gt;&lt;a href=&quot;#1、系统模型&quot; class=&quot;headerlink&quot; title=&quot;1、系统模型&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/categories/Zookeeper/"/>
    
    
    <category term="深入原理" scheme="https://blog.lee81.cn/tags/%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86/"/>
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper客户端使用</title>
    <link href="https://blog.lee81.cn/2020/04/12/Zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.lee81.cn/2020/04/12/Zookeeper%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-12T01:15:08.000Z</published>
    <updated>2022-08-13T12:29:03.591Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章借鉴了《从Paxos到Zookeeper分布式一致性原理与实践》</p></blockquote><p>本篇将会介绍Zookeeper自带的客户端脚本，Java客户端API和开源客户端。</p><h3 id="1、客户端脚本"><a href="#1、客户端脚本" class="headerlink" title="1、客户端脚本"></a>1、客户端脚本</h3><p>在Zookeeper的安装目录下的 <strong>/bin</strong> 文件夹中有一个 <strong>zkCli.sh</strong> 脚本，这个是官方提供的客户端脚本。</p><h4 id="1-1、连接"><a href="#1-1、连接" class="headerlink" title="1.1、连接"></a>1.1、连接</h4><p>可以直接运行zkCli.sh脚本，默认就是连接本地的Zookeeper服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh zkCli.sh</span><br></pre></td></tr></table></figure><p>如果想连接指定的Zookeeper服务器，需要在后面添加一些参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh zkCli.sh -server ip:port</span><br></pre></td></tr></table></figure><ul><li>-server：表示指定Zookeeper服务器，后面跟服务器的IP地址和端口号。</li></ul><p><strong>例子：</strong></p><p>指定连接 192.168.0.10 上的 Zookeeper 服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh zkCli.sh -server 192.168.0.10:2181</span><br></pre></td></tr></table></figure><h4 id="1-2、创建"><a href="#1-2、创建" class="headerlink" title="1.2、创建"></a>1.2、创建</h4><p>使用 create 命令可以创建一个 ZNode 节点。默认创建永久节点。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create [-s] [-e] path data acl</span><br></pre></td></tr></table></figure><ul><li>-s：表示创建一个顺序节点。</li><li>-e：表示创建一个临时节点。</li><li>path：表示要创建的节点路径名。</li><li>data：表示要创建的节点数据。</li><li>acl：表示要创建的节点的访问控制列表。可以不写，默认为 world:anyone:cdrwa。</li></ul><p><strong>注意：</strong></p><ul><li>不可以递归创建。例如：创建 /create/node 节点时，其父节点 /create 必须已经存在。</li><li>临时节点下不可以创建子节点。</li></ul><p><strong>例子：</strong></p><p>创建一个永久顺序节点，节点路径为 <strong>/node</strong>，节点数据为 <strong>node</strong>，访问控制列表为 ip:192.168.0.10:cdrwa**。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create -s /node &quot;node&quot; ip:192.168.0.10:cdrwa</span><br></pre></td></tr></table></figure><h4 id="1-3、读取"><a href="#1-3、读取" class="headerlink" title="1.3、读取"></a>1.3、读取</h4><h5 id="1-3-1、ls"><a href="#1-3-1、ls" class="headerlink" title="1.3.1、ls"></a>1.3.1、ls</h5><p>使用 ls 命令可以列出 Zookeeper 指定节点下的所有下级节点。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls path [watch]</span><br></pre></td></tr></table></figure><ul><li>path：表示要查询的节点路径。</li><li>watch：表示是否开启监控，监控 path 下的子节点变化（NodeChildrenChanged，NodeDeleted）。</li></ul><p><strong>例子：</strong></p><p>列出根节点下的所有子节点。**/** 表示根节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure><h5 id="1-3-3、ls2"><a href="#1-3-3、ls2" class="headerlink" title="1.3.3、ls2"></a>1.3.3、ls2</h5><p>使用 ls2 命令可以列出 Zookeeper 指定节点下的所有下级节点，并且显示当前节点的属性信息。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls2 path [watch]</span><br></pre></td></tr></table></figure><ul><li>path：表示要查询的节点路径。</li><li>watch：表示是否开启监控，监控 path 下的子节点变化。</li></ul><p><strong>例子：</strong></p><p>列出根节点下的所有子节点，并且查看根节点的属性信息。**/** 表示根节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls2 /</span><br></pre></td></tr></table></figure><h5 id="1-3-2、get"><a href="#1-3-2、get" class="headerlink" title="1.3.2、get"></a>1.3.2、get</h5><p>使用 get 命令可以获取 Zookeeper 指定节点的数据内容和属性信息。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get path [watch]</span><br></pre></td></tr></table></figure><ul><li>path：表示要查询的节点路径。</li><li>watch：表示是否开启监控，监控节点变化（NodeDataChanged，NodeDeleted）。</li></ul><p><strong>例子：</strong></p><p>获取 /node 节点的数据和属性信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /node</span><br></pre></td></tr></table></figure><h4 id="1-4、更新"><a href="#1-4、更新" class="headerlink" title="1.4、更新"></a>1.4、更新</h4><p>使用 set 命令可以更新指定节点的数据内容。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set path data [version]</span><br></pre></td></tr></table></figure><ul><li>path：表示要更新的节点路径名。</li><li>data：表示要更新的节点数据。</li><li>version：表示指定基于哪个节点数据版本进行更新。</li></ul><p><strong>例子：</strong></p><p>更新 /node 节点数据为 test。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set /node &quot;test&quot;</span><br></pre></td></tr></table></figure><h4 id="1-5、删除"><a href="#1-5、删除" class="headerlink" title="1.5、删除"></a>1.5、删除</h4><h5 id="1-5-1、delete"><a href="#1-5-1、delete" class="headerlink" title="1.5.1、delete"></a>1.5.1、delete</h5><p>使用 delete 命令可以删除 Zookeeper 上的指定节点。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete path [version]</span><br></pre></td></tr></table></figure><ul><li>path：表示要删除的节点路径名。</li><li>version：表示指定基于哪个节点数据版本进行删除。</li></ul><p><strong>注意：</strong>不支持递归删除。例如：删除 /create 节点时，其节点下不能存在子节点。</p><p><strong>例子：</strong></p><p>删除 /node 节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete /node</span><br></pre></td></tr></table></figure><h5 id="1-5-2、rmr"><a href="#1-5-2、rmr" class="headerlink" title="1.5.2、rmr"></a>1.5.2、rmr</h5><p>使用 rmr 命令可以递归删除 Zookeeper 上的指定节点和其所有的子节点。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmr path</span><br></pre></td></tr></table></figure><ul><li>path：表示要删除的节点路径名。</li></ul><p><strong>例子：</strong></p><p>删除 /node 节点和其下的所有子节点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmr /node</span><br></pre></td></tr></table></figure><h4 id="1-6、ACL"><a href="#1-6、ACL" class="headerlink" title="1.6、ACL"></a>1.6、ACL</h4><h5 id="1-6-1、setAcl"><a href="#1-6-1、setAcl" class="headerlink" title="1.6.1、setAcl"></a>1.6.1、setAcl</h5><p>使用 setAcl 命令可以设置 Zookeeper 上的指定节点的访问控制列表，即访问权限。具体可以设置哪些访问权限，请阅读 Zookeeper深入原理。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl path acl</span><br></pre></td></tr></table></figure><ul><li>path：表示要设置权限的节点路径名。</li><li>acl：表示要设置的权限列表，可以设置多种权限。</li></ul><p><strong>例子：</strong></p><p>为 /node 节点设置权限 <strong>ip:192.168.0.10:cdrwa</strong> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAcl /node ip:192.168.0.10:cdrwa</span><br></pre></td></tr></table></figure><h5 id="1-6-2、getAcl"><a href="#1-6-2、getAcl" class="headerlink" title="1.6.2、getAcl"></a>1.6.2、getAcl</h5><p>使用 getAcl 命令可以获取 Zookeeper 上的指定节点的访问控制列表。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getAcl path</span><br></pre></td></tr></table></figure><ul><li>path：表示要获取权限的节点路径名。</li></ul><p><strong>例子：</strong></p><p>获取 /node 节点的访问控制列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getAcl /node</span><br></pre></td></tr></table></figure><h4 id="1-7、其他"><a href="#1-7、其他" class="headerlink" title="1.7、其他"></a>1.7、其他</h4><h5 id="1-7-1、stat"><a href="#1-7-1、stat" class="headerlink" title="1.7.1、stat"></a>1.7.1、stat</h5><p>使用 stat 命令可以获取 Zookeeper 上的指定节点的属性信息。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat path [watch]</span><br></pre></td></tr></table></figure><ul><li>path：表示要获取属性信息的节点路径名。</li><li>watch：表示是否开启监控，监控节点变化（NodeDataChanged，NodeDeleted）。</li></ul><p><strong>例子：</strong></p><p>查看 /node 节点属性信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat /node</span><br></pre></td></tr></table></figure><h5 id="1-7-2、connect"><a href="#1-7-2、connect" class="headerlink" title="1.7.2、connect"></a>1.7.2、connect</h5><p>使用 connect 命令可以连接 Zookeeper 上的指定服务器。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect host:port</span><br></pre></td></tr></table></figure><ul><li>host：表示要连接的 Zookeeper 服务器IP。</li><li>port：表示要连接的 Zookeeper 服务器端口号。</li></ul><p><strong>例子：</strong></p><p>连接 192.168.0.12:2181 Zookeeper 服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect 192.168.0.12:2181</span><br></pre></td></tr></table></figure><h5 id="1-7-3、close"><a href="#1-7-3、close" class="headerlink" title="1.7.3、close"></a>1.7.3、close</h5><p>使用 close 命令可以关闭当前会话。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close</span><br></pre></td></tr></table></figure><h5 id="1-7-4、quit"><a href="#1-7-4、quit" class="headerlink" title="1.7.4、quit"></a>1.7.4、quit</h5><p>使用 quit 命令可以退出当前客户端。用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><h3 id="2、Java客户端API"><a href="#2、Java客户端API" class="headerlink" title="2、Java客户端API"></a>2、Java客户端API</h3><p>Zookeeper 官方提供了很多编程语言的客户端API，这里我只介绍Java客户端API。</p><p>API地址：<a href="https://zookeeper.apache.org/doc/r3.4.14/api/index.html">https://zookeeper.apache.org/doc/r3.4.14/api/index.html</a></p><h4 id="2-1、创建会话"><a href="#2-1、创建会话" class="headerlink" title="2.1、创建会话"></a>2.1、创建会话</h4><p>客户端可以通过创建一个 Zookeeper（org.apache.zookeeper.Zookeeper） 实例来连接 Zookeeper服务器。</p><p><strong>API列表：</strong></p><ul><li><strong>Zookeeper</strong>(String connectString, int sessionTimeout, Watcher watcher)</li><li><strong>Zookeeper</strong>(String connectString, int sessionTimeout, Watcher watcher, boolean canBeReadOnly)</li><li><strong>Zookeeper</strong>(String connectString, int sessionTimeout, Watcher watcher, long sessionId, byte[] sessionPasswd)</li><li><strong>Zookeeper</strong>(String connectString, int sessionTimeout, Watcher watcher, long sessionId, byte[] sessionPasswd, boolean canBeReadOnly)</li></ul><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>connectString</td><td>Zookeeper服务器连接地址，多个服务器可以使用 <strong>,</strong> 连接。例如：192.168.0.10:2181,192.168.0.11:2181,192.168.0.12:2181</td></tr><tr><td>sessionTimeout</td><td>指会话的超时时间，单位是毫秒。</td></tr><tr><td>watcher</td><td>Zookeeper允许客户端在构造方法中传入一个接口 Watcher 的实现类对象来作为默认的 Watcher 事件通知处理器。该参数也可以设置为 null，表明不设置默认的 Watcher 处理器。</td></tr><tr><td>canBeReadOnly</td><td>这是一个 boolean 类型的参数，用于标识当前会话是否支持只读模式。</td></tr><tr><td>sessionId 和 sessionPasswd</td><td>分别代表会话ID 和 会话密钥。这两个参数能够唯一确定一个会话，同时客户端可以使用这两个参数实现客户端会话复用，从而达到恢复会话的效果。</td></tr></tbody></table><p><strong>例子：</strong></p><p>注意：Zookeeper客户端和服务器会话的建立是一个异步过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZookeeperConnect</span> &#123;</span><br><span class="line">    <span class="comment">//阻塞主线程，等待会话创建成功</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建Zookeeper对象，连接服务器</span></span><br><span class="line"><span class="type">ZooKeeper</span> <span class="variable">zooKeeper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>(<span class="string">&quot;192.168.0.10:2181&quot;</span>, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Watcher</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(WatchedEvent watchedEvent)</span> &#123;</span><br><span class="line">                <span class="comment">//连接成功</span></span><br><span class="line">                <span class="keyword">if</span>(Event.KeeperState.SyncConnected.equals(watchedEvent.getState()))&#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Event.KeeperState.Disconnected.equals(watchedEvent.getState()))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;连接失败......&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Event.KeeperState.AuthFailed.equals(watchedEvent.getState()))&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;用户认证失败......&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//等待连接成功</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、创建节点"><a href="#2-2、创建节点" class="headerlink" title="2.2、创建节点"></a>2.2、创建节点</h4><p>客户端可以通过Zookeeper的API来创建一个数据节点。</p><p><strong>API列表：</strong></p><ul><li>String  <strong>create</strong>(String path, byte[] data, List<ACL> acl, CreateMode createMode)</li><li>void <strong>create</strong>(String path, byte[] data, List<ACL> acl, CreateMode createMode, AsyncCallback.StringCallback cb, Object ctx)</li></ul><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>path</td><td>要创建的节点路径。</td></tr><tr><td>data</td><td>要创建的节点的数据内容。</td></tr><tr><td>acl</td><td>要创建的节点访问控制列表。</td></tr><tr><td>createMode</td><td>要创建的节点的节点类型。节点类型：持久，持久顺序，临时，临时顺序。</td></tr><tr><td>cb</td><td>回调函数，用于异步创建时使用。</td></tr><tr><td>ctx</td><td>上下文信息，用于异步创建时传递数据使用。</td></tr></tbody></table><h4 id="2-3、读取数据"><a href="#2-3、读取数据" class="headerlink" title="2.3、读取数据"></a>2.3、读取数据</h4><p>读取数据包括节点数据的获取和子节点列表的获取。</p><h5 id="2-3-1、getData"><a href="#2-3-1、getData" class="headerlink" title="2.3.1、getData"></a>2.3.1、getData</h5><p>客户端可以通过 Zookeeper 的 API 来获取一个节点的数据内容。</p><p><strong>API列表：</strong></p><ul><li>byte[] <strong>getData</strong>(String path, boolean watch, Stat stat)</li><li>byte[] <strong>getData</strong>(String path, Watcher watcher, Stat stat)</li><li>void <strong>getData</strong>(String path, boolean watch, AsyncCallback.DataCallback cb, Object ctx)</li><li>void <strong>getData</strong>(java.lang.String path, Watcher watcher, AsyncCallback.DataCallback cb, Object ctx)</li></ul><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>path</td><td>指定数据节点的节点路径</td></tr><tr><td>watch</td><td>表明是否需要注册一个 Watcher。如果是就使用默认的 Watcher。</td></tr><tr><td>stat</td><td>指定数据节点的状态信息。</td></tr><tr><td>watcher</td><td>注册Watcher。</td></tr><tr><td>cb</td><td>回调函数，用于异步获取数据时使用。</td></tr><tr><td>ctx</td><td>上下文信息，用于异步获取数据时传递数据使用。</td></tr></tbody></table><h5 id="2-3-2、getChildren"><a href="#2-3-2、getChildren" class="headerlink" title="2.3.2、getChildren"></a>2.3.2、getChildren</h5><p>客户端可以通过 Zookeeper 的 API 来获取一个节点的所有子节点。</p><p><strong>API列表：</strong></p><ul><li>List<String> <strong>getChildren</strong>(String path, boolean watch)</li><li>void <strong>getChildren</strong>(String path, boolean watch, AsyncCallback.Children2Callback cb, Object ctx)</li><li>void <strong>getChildren</strong>(String path, boolean watch, AsyncCallback.ChildrenCallback cb, Object ctx)</li><li>List<String> <strong>getChildren</strong>(String path, boolean watch, Stat stat)</li><li>List<String> <strong>getChildren</strong>(String path, Watcher watcher)</li><li>void <strong>getChildren</strong>(String path, Watcher watcher, AsyncCallback.Children2Callback cb, Object ctx)</li><li>void <strong>getChildren</strong>(String path, Watcher watcher, AsyncCallback.ChildrenCallback cb, Object ctx)</li><li>List<String> <strong>getChildren</strong>(String path, Watcher watcher, Stat stat)</li></ul><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>path</td><td>指定数据节点的节点路径。</td></tr><tr><td>watch</td><td>表明是否需要注册一个 Watcher。如果是就使用默认的 Watcher。</td></tr><tr><td>watcher</td><td>注册Watcher。</td></tr><tr><td>cb</td><td>回调函数，用于异步获取数据时使用。</td></tr><tr><td>ctx</td><td>上下文信息，用于异步获取数据时传递数据使用。</td></tr><tr><td>stat</td><td>指定数据节点的节点状态信息。</td></tr></tbody></table><h4 id="2-4、更新数据"><a href="#2-4、更新数据" class="headerlink" title="2.4、更新数据"></a>2.4、更新数据</h4><p>客户端可以通过 Zookeeper 的 API 来更新一个节点的数据内容。</p><p><strong>API列表：</strong></p><ul><li>Stat <strong>setData</strong>(String path, byte[] data, int version)</li><li>void <strong>setData</strong>(String path, byte[] data, int version, AsyncCallback.StatCallback cb, Object ctx)</li></ul><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>path</td><td>指定数据节点的节点路径。</td></tr><tr><td>data[]</td><td>一个字节数组，即需要使用该数据内容来覆盖节点现在的数据内容。</td></tr><tr><td>version</td><td>指定节点的数据版本。</td></tr><tr><td>cb</td><td>回调函数，用于异步更新数据时使用。</td></tr><tr><td>ctx</td><td>上下文信息，用于异步更新数据时传递数据使用。</td></tr></tbody></table><h4 id="2-5、删除节点"><a href="#2-5、删除节点" class="headerlink" title="2.5、删除节点"></a>2.5、删除节点</h4><p>客户端可以通过Zookeeper的API来删除一个数据节点。</p><p><strong>API列表：</strong></p><ul><li>void <strong>delete</strong>(String path, int version)</li><li>void <strong>delete</strong>(String path, int version, AsyncCallback.VoidCallback cb, Object ctx)</li></ul><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>path</td><td>要删除的节点路径</td></tr><tr><td>version</td><td>指定节点的数据版本</td></tr><tr><td>cb</td><td>回调函数，用于异步删除时使用。</td></tr><tr><td>ctx</td><td>上下文信息，用于异步删除时传递数据使用。</td></tr></tbody></table><h4 id="2-6、检测节点是否存在"><a href="#2-6、检测节点是否存在" class="headerlink" title="2.6、检测节点是否存在"></a>2.6、检测节点是否存在</h4><p>客户端可以通过 Zookeeper 的 API 来检测节点是否存在。</p><p><strong>API列表：</strong></p><ul><li>State <strong>exists</strong>(String path, boolean watch)</li><li>State <strong>exists</strong>(String path, Watcher watcher)</li><li>void <strong>exists</strong>(String path, boolean watch, AsyncCallback.StatCallback cb, Object ctx)</li><li>void <strong>exists</strong>(String path, Watcher watcher, AsyncCallback.StatCallback cb, Object ctx)</li></ul><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>path</td><td>指定数据节点的节点路径。</td></tr><tr><td>watch</td><td>指定是否复用 Zookeeper 中默认的 Watcher。</td></tr><tr><td>watcher</td><td>注册的Watcher，用于监听以下三类事件：节点被创建、节点被删除、节点被更新</td></tr><tr><td>cb</td><td>回调函数，用于异步检测节点是否存在时使用。</td></tr><tr><td>ctx</td><td>上下文信息，用于异步检测节点是否存在时传递数据使用。</td></tr></tbody></table><h3 id="3、开源客户端"><a href="#3、开源客户端" class="headerlink" title="3、开源客户端"></a>3、开源客户端</h3><h4 id="3-1、ZkClient"><a href="#3-1、ZkClient" class="headerlink" title="3.1、ZkClient"></a>3.1、ZkClient</h4><p>ZkClient 是 Github 上一个开源的 Zookeeper 客户端，是由 Datameer 的工程师 Stefan Groschupf 和 Peter Voss 一起开发的。ZkClient 在 Zookeeper 原生 API 接口之上进行了包装，是一个更易用的Zookeeper 客户端。同时，ZkClient 在内部实现了诸如 Session 超时重连、Watcher 反复注册等功能，使得 Zookeeper 客户端的这些繁琐的细节工作对开发人员透明。</p><p>这里我就不演示使用方法了，自己去探索研究吧。</p><h4 id="3-2、Curator"><a href="#3-2、Curator" class="headerlink" title="3.2、Curator"></a>3.2、Curator</h4><p>Curator 是 Netflix 公司开源的一套 Zookeeper 客户端框架，其作者是 Jordan Zimmerman。和 ZkClient 一样，Curator 解决了很多 Zookeeper 客户端非常底层的细节开发工作，包括连接重连、反复注册 Watcher 和 NodeExistsException 异常等，目前已经成为了 Apache 的顶级项目，是全世界范围内使用最广泛的 Zookeeper 客户端之一。并且，Curator 在 Zookeeper 原生API的基础上进行了包装，提供了一套易用性和可读性更强的 Fluent 风格的客户端 API 框架。</p><p>除此之外，Curator 中还提供了 Zookeeper 各种应用场景（Recipe，如共享锁服务、Master选举机制和分布式计数器等）的抽象封装。</p><p>官网地址：<a href="http://curator.apache.org/">http://curator.apache.org/</a></p><p>同样，这里我就不演示使用方法了，自己去探索研究吧。</p><p>源码地址：<a href="https://gitee.com/lingfeng1024/stu-zookeeper">https://gitee.com/lingfeng1024/stu-zookeeper</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章借鉴了《从Paxos到Zookeeper分布式一致性原理与实践》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇将会介绍Zookeeper自带的客户端脚本，Java客户端API和开源客户端。&lt;/p&gt;
&lt;h3 id=&quot;1、客户端脚本&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/categories/Zookeeper/"/>
    
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/tags/Zookeeper/"/>
    
    <category term="客户端" scheme="https://blog.lee81.cn/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper集群搭建</title>
    <link href="https://blog.lee81.cn/2020/04/11/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.lee81.cn/2020/04/11/Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</id>
    <published>2020-04-10T17:12:44.000Z</published>
    <updated>2022-08-13T12:29:03.593Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章借鉴了《从Paxos到Zookeeper分布式一致性原理与实践》</p></blockquote><p>Zookeeper有两种运行模式：单机模式和集群模式。因为单机模式只是在开发测试时使用，所以这里就不介绍单机模式的搭建。</p><h3 id="1、集群规划"><a href="#1、集群规划" class="headerlink" title="1、集群规划"></a>1、集群规划</h3><p>注意：因为Zookeeper遵循半数原则，所以集群节点个数最好是奇数。</p><table><thead><tr><th>IP地址</th><th>系统</th><th>环境</th></tr></thead><tbody><tr><td>192.168.0.10</td><td>CentOS7</td><td>jdk8</td></tr><tr><td>192.168.0.11</td><td>CentOS7</td><td>jdk8</td></tr><tr><td>192.168.0.12</td><td>CentOS7</td><td>jdk8</td></tr></tbody></table><h3 id="2、下载安装"><a href="#2、下载安装" class="headerlink" title="2、下载安装"></a>2、下载安装</h3><h4 id="2-1、下载"><a href="#2-1、下载" class="headerlink" title="2.1、下载"></a>2.1、下载</h4><p>下载地址：<a href="http://archive.apache.org/dist/zookeeper/">http://archive.apache.org/dist/zookeeper/</a></p><p>根据自己的需求，选择相对应的版本，我这是用的是zookeeper-3.4.14。</p><h4 id="2-2、安装"><a href="#2-2、安装" class="headerlink" title="2.2、安装"></a>2.2、安装</h4><p>将下载好的压缩包，解压到自己指定的路径下，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.14.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure><h3 id="3、配置文件参数说明"><a href="#3、配置文件参数说明" class="headerlink" title="3、配置文件参数说明"></a>3、配置文件参数说明</h3><p>进入到 conf/ 目录下，里面有一个 zoo_sample.cfg 文件，这个就是zookeeper的配置文件。我们先对里面的参数介绍下：</p><table><thead><tr><th align="left">参数名</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">tickTime</td><td align="left">2000</td><td align="left">单位是毫秒（ms）。表示zookeeper中的最小时间单元的长度，其他参数都是以tickTime为单位来配置。</td></tr><tr><td align="left">initLimit</td><td align="left">10</td><td align="left">单位是tickTime。表示允许Follower初始化连接到Leader并完成数据同步的超时时间，如果ZooKeeper管理的数据量很大，请根据需要增加此值。</td></tr><tr><td align="left">syncLimit</td><td align="left">5</td><td align="left">单位是tickTime。表示Leader与Follower之间进行心跳检测的最大延时时间。如果超过时间，那么Leader认为该Follower已经脱离了集群。</td></tr><tr><td align="left">dataDir</td><td align="left">无</td><td align="left"><strong>必须配置。</strong>用于配置Zookeeper服务器存储快照文件的目录。</td></tr><tr><td align="left">dataLogDir</td><td align="left">dataDir</td><td align="left">用于配置Zookeeper服务器存储事务日志文件的目录。推荐配置为单独的一个磁盘上，因为事务日志写入的性能直接决定了Zookeeper在处理事务请求时的吞吐。</td></tr><tr><td align="left">clientPort</td><td align="left">2181</td><td align="left"><strong>必须配置。</strong>用于配置当前服务器对外的服务端口，客户端会通过该端口和Zookeeper服务器创建连接。</td></tr><tr><td align="left">snapCount</td><td align="left">100000</td><td align="left">用于配置相邻两次数据快照之间的事务操作次数，即Zookeeper会在snapCount次事务操作之后进行一次数据快照。</td></tr><tr><td align="left">preAllocSize</td><td align="left">65536</td><td align="left">单位是KB。用于配置Zookeeper事务日志文件预分配的磁盘空间大小。</td></tr><tr><td align="left">minSessionTimeout</td><td align="left">2</td><td align="left">单位是tickTime。用于配置服务端和客户端会话超时时间的最小值。</td></tr><tr><td align="left">maxSessionTimeout</td><td align="left">20</td><td align="left">单位是tickTime。用于配置服务端和客户端会话超时时间的最大值。</td></tr><tr><td align="left">maxClientCnxns</td><td align="left">60</td><td align="left">用于从Socket层面限制单个客户端与单台服务器之间的并发连接数，即以IP地址粒度来进行连接数的限制。如果将该参数设置为0，则表示对连接数不作任何限制。</td></tr><tr><td align="left">server.id=host:port:port</td><td align="left">无</td><td align="left">用于配置组成Zookeeper集群的机器列表,其中id即为ServerID，与每台服务器myid文件中的数字相对应。同时,在该参数中，会配置两个端口：第一个端口用于指定Follower服务器与Leader进行运行时通信和数据同步时所使用的端口，第二个端口则专门用于进行Leader选举过程中的投票通信。</td></tr><tr><td align="left">autopurge.snapRetainCont</td><td align="left">3</td><td align="left">用于配置Zookeeper在自动清理的时候需要保留的快照数据文件数量和对应的事务日志文件。需要注意的是，并不是磁盘上的所有事务日志和快照数据文件都可以被清理掉——那样的话将无法恢复数据。因此 autopurge.snapRetainCont 的最小值是3，如果配置的 autopurge.snapRetainCont 值比3小的话，那么会被自动调整到3，即至少需要保留3个快照数据文件和对应的事务日志文件。</td></tr><tr><td align="left">autopurge.purgeInterval</td><td align="left">0</td><td align="left">单位是小时。用于配置Zookeeper进行历史文件自动清理的频率。如果配置该值为0或负数，那么就表明不需要开启定时清理功能。</td></tr></tbody></table><h3 id="4、修改配置"><a href="#4、修改配置" class="headerlink" title="4、修改配置"></a>4、修改配置</h3><h4 id="4-1、修改配置文件"><a href="#4-1、修改配置文件" class="headerlink" title="4.1、修改配置文件"></a>4.1、修改配置文件</h4><p>先将 zoo_sample.cfg 文件重命名为zoo.cfg，然后修改里面的参数，我修改的参数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=/data/zookeeper/data</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=192.168.0.10:2888:3888</span><br><span class="line">server.2=192.168.0.11:2888:3888</span><br><span class="line">server.3=192.168.0.12:2888:3888</span><br></pre></td></tr></table></figure><p><strong>注意：这里只进行了简单的配置，请根据自己的业务需求进行修改。</strong></p><h4 id="4-2、创建数据目录"><a href="#4-2、创建数据目录" class="headerlink" title="4.2、创建数据目录"></a>4.2、创建数据目录</h4><p>根据配置文件中的dataDir参数创建对应的目录，然后在此目录下创建名为myid的文件，添加配置的当前节点id。</p><h3 id="5、配置其他机器"><a href="#5、配置其他机器" class="headerlink" title="5、配置其他机器"></a>5、配置其他机器</h3><p>根据上面的步骤在其他两台机器上进行配置。</p><p><strong>注意：一定要修改myid文件中的数据为对应节点的id。</strong></p><h3 id="6、启动与关闭服务"><a href="#6、启动与关闭服务" class="headerlink" title="6、启动与关闭服务"></a>6、启动与关闭服务</h3><p>在根目录中有一个 /bin 文件夹，zookeeper中所有的命令都在这个目录下。</p><h4 id="6-1、启动服务"><a href="#6-1、启动服务" class="headerlink" title="6.1、启动服务"></a>6.1、启动服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh start</span><br></pre></td></tr></table></figure><h4 id="6-2、查看服务状态"><a href="#6-2、查看服务状态" class="headerlink" title="6.2、查看服务状态"></a>6.2、查看服务状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh status</span><br></pre></td></tr></table></figure><h4 id="6-2、关闭服务"><a href="#6-2、关闭服务" class="headerlink" title="6.2、关闭服务"></a>6.2、关闭服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./zkServer.sh stop</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章借鉴了《从Paxos到Zookeeper分布式一致性原理与实践》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Zookeeper有两种运行模式：单机模式和集群模式。因为单机模式只是在开发测试时使用，所以这里就不介绍单机模式的搭建。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/categories/Zookeeper/"/>
    
    
    <category term="集群搭建" scheme="https://blog.lee81.cn/tags/%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Zookeeper" scheme="https://blog.lee81.cn/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Nginx深入原理</title>
    <link href="https://blog.lee81.cn/2020/03/22/Nginx%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.lee81.cn/2020/03/22/Nginx%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86/</id>
    <published>2020-03-22T07:28:19.000Z</published>
    <updated>2022-08-13T12:29:03.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p><img src="1.PNG"></p><p><img src="2.PNG"></p><h3 id="2、master-workers-的机制的好处"><a href="#2、master-workers-的机制的好处" class="headerlink" title="2、master-workers 的机制的好处"></a>2、master-workers 的机制的好处</h3><p>首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，<br>同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会<br>影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的<br>worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当<br>前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</p><h3 id="3、worker数量设置"><a href="#3、worker数量设置" class="headerlink" title="3、worker数量设置"></a>3、worker数量设置</h3><p>Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进<br>程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的 cpu数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p><blockquote><p>worker_processes 4<br>#work 绑定 cpu(4 work 绑定 4cpu)。<br>worker_cpu_affinity 0001 0010 0100 1000<br>#work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。<br>worker_cpu_affinity 0000001 00000010 00000100 00001000</p></blockquote><h3 id="4、worker-connection-数量设置"><a href="#4、worker-connection-数量设置" class="headerlink" title="4、worker_connection 数量设置"></a>4、worker_connection 数量设置</h3><p>这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是 worker_connections * worker_processes，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通静态访问最大并发数是：worker_connections * worker_processes /2，而如果是 HTTP 作 为反向代理来说，最大并发数量是：worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a&gt;1、概述&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;1.PNG&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2.PNG&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、maste</summary>
      
    
    
    
    <category term="Nginx" scheme="https://blog.lee81.cn/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://blog.lee81.cn/tags/Nginx/"/>
    
    <category term="深入原理" scheme="https://blog.lee81.cn/tags/%E6%B7%B1%E5%85%A5%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Nginx负载均衡</title>
    <link href="https://blog.lee81.cn/2020/03/21/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://blog.lee81.cn/2020/03/21/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2020-03-21T08:41:57.000Z</published>
    <updated>2022-08-13T12:29:03.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例"><a href="#1、案例" class="headerlink" title="1、案例"></a>1、案例</h3><h4 id="1-1、需求"><a href="#1-1、需求" class="headerlink" title="1.1、需求"></a>1.1、需求</h4><p>使用 nginx （192.168.150.101）负载均衡，在本机（192.168.150.100）访问 <a href="http://www.ld.com/test/index.html">www.ld.com/test/index.html</a> 跳转到 192.168.150.102:8080/test/index.html或192.168.150.103:8080/test/index.html 。</p><h4 id="1-2、配置"><a href="#1-2、配置" class="headerlink" title="1.2、配置"></a>1.2、配置</h4><ul><li>step1：修改本机 hosts 文件，位置：C:\Windows\System32\drivers\etc\，并在文件最后添加如下配置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.150.101 www.ld.com</span><br></pre></td></tr></table></figure></li><li>step2：修改nginx.conf，在文件中的 http 块中添加如下配置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">upstream ldserver &#123;</span><br><span class="line">     server 192.168.150.102:8080;</span><br><span class="line">     server 192.168.150.103:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name www.ld.com</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://ldserver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>step3：在102和103服务器上 tomcat 的webapp目录下分别添加文件夹test,并在文件夹下添加index.html，并启动。<blockquote><p>102服务器上的index.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，我是102<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>103服务器上的index.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，我是103<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>step4：在浏览器上多次访问 <a href="http://www.ld.com/test/index.html%EF%BC%8C%E5%BE%AA%E7%8E%AF%E6%98%BE%E7%A4%BA%E5%A6%82%E4%B8%8B%E9%A1%B5%E9%9D%A2%EF%BC%9A">http://www.ld.com/test/index.html，循环显示如下页面：</a></li></ul><p><img src="1.PNG"></p><p><img src="2.PNG"></p><h3 id="2、Nginx-支持的负载均衡策略"><a href="#2、Nginx-支持的负载均衡策略" class="headerlink" title="2、Nginx 支持的负载均衡策略"></a>2、Nginx 支持的负载均衡策略</h3><ul><li>轮询（默认）</li></ul><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</p><ul><li>weight</li></ul><p>weight 代表权重，默认为1，权重越高被分配的客户端越多<br>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream server_pool &#123;</span><br><span class="line">    server  192.168.150.102:8080 weight=10;</span><br><span class="line">    server  192.168.150.103:8080 weight=5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ip_hash</li></ul><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决session 的问题。<br>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream server_pool &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server  192.168.150.102:8080;</span><br><span class="line">    server  192.168.150.103:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>fair</li></ul><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br><strong>注意：需要安装插件，因为是第三方的。</strong><br>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream server_pool &#123;</span><br><span class="line">    fair;</span><br><span class="line">    server  192.168.150.102:8080;</span><br><span class="line">    server  192.168.150.103:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、案例&quot;&gt;&lt;a href=&quot;#1、案例&quot; class=&quot;headerlink&quot; title=&quot;1、案例&quot;&gt;&lt;/a&gt;1、案例&lt;/h3&gt;&lt;h4 id=&quot;1-1、需求&quot;&gt;&lt;a href=&quot;#1-1、需求&quot; class=&quot;headerlink&quot; title=&quot;1.1、需</summary>
      
    
    
    
    <category term="Nginx" scheme="https://blog.lee81.cn/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://blog.lee81.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx反向代理</title>
    <link href="https://blog.lee81.cn/2020/03/21/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://blog.lee81.cn/2020/03/21/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</id>
    <published>2020-03-21T06:36:01.000Z</published>
    <updated>2022-08-13T12:29:03.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、案例一"><a href="#1、案例一" class="headerlink" title="1、案例一"></a>1、案例一</h3><h4 id="1-1、需求"><a href="#1-1、需求" class="headerlink" title="1.1、需求"></a>1.1、需求</h4><p>使用 nginx （192.168.150.101）反向代理，在本机（192.168.150.100）访问 <a href="http://www.ld.com/">www.ld.com</a> 直接跳转到 192.168.150.102:8080 。</p><h4 id="1-2、配置"><a href="#1-2、配置" class="headerlink" title="1.2、配置"></a>1.2、配置</h4><ul><li>step1：修改本机 hosts 文件，位置：C:\Windows\System32\drivers\etc\，并在文件最后添加如下配置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.150.101 www.ld.com</span><br></pre></td></tr></table></figure></li><li>step2：修改nginx.conf，在文件中的 http 块中添加如下配置。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name www.ld.com</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://192.168.150.102:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>step3：启动tomcat，使用默认的端口号。</li><li>step4：在浏览器上访问 <a href="http://www.ld.com,出现如下效果就算成功./">www.ld.com，出现如下效果就算成功。</a><br><img src="1.PNG"></li></ul><h3 id="2、案例二"><a href="#2、案例二" class="headerlink" title="2、案例二"></a>2、案例二</h3><h4 id="2-1、需求"><a href="#2-1、需求" class="headerlink" title="2.1、需求"></a>2.1、需求</h4><p>使用 nginx（192.168.150.101）反向代理，在本机（192.168.150.100）访问 不同的地址，跳转到不同的tomcat中。<br>地址1：<a href="http://www.ld.com/102/index.html">www.ld.com/102/index.html</a> ,目标：192.168.150.102:8080<br>地址2：<a href="http://www.ld.com/103/index.html">www.ld.com/103/index.html</a> ,目标：192.168.150.103:8080</p><h4 id="2-2、配置"><a href="#2-2、配置" class="headerlink" title="2.2、配置"></a>2.2、配置</h4><ul><li><p>step1：修改本机 hosts 文件，位置：C:\Windows\System32\drivers\etc\，并在文件最后添加如下配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.150.101 www.ld.com</span><br></pre></td></tr></table></figure></li><li><p>step2：修改nginx.conf，在文件中的 http 块中添加如下配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name www.ld.com</span><br><span class="line">    </span><br><span class="line">    location ~ /102/ &#123;</span><br><span class="line">        proxy_pass   http://192.168.150.102:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location ~ /103/ &#123;</span><br><span class="line">        proxy_pass   http://192.168.150.103:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>step3：在102和103服务器上 tomcat 的webapp目录下分别添加文件夹102,103,并在文件夹下添加index.html，并启动。</p><blockquote><p>102服务器上的index.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，我是102<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>103服务器上的index.html</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，我是103<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>step4：在浏览器上分别访问不同的url</p><p>地址1：<a href="http://www.ld.com/102/index.html">www.ld.com/102/index.html</a> </p></li></ul><p><img src="2.1.PNG"></p><p>​        地址2：<a href="http://www.ld.com/103/index.html">www.ld.com/103/index.html</a> </p><p><img src="2.2.PNG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、案例一&quot;&gt;&lt;a href=&quot;#1、案例一&quot; class=&quot;headerlink&quot; title=&quot;1、案例一&quot;&gt;&lt;/a&gt;1、案例一&lt;/h3&gt;&lt;h4 id=&quot;1-1、需求&quot;&gt;&lt;a href=&quot;#1-1、需求&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="Nginx" scheme="https://blog.lee81.cn/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://blog.lee81.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx动静分离</title>
    <link href="https://blog.lee81.cn/2020/03/15/Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/"/>
    <id>https://blog.lee81.cn/2020/03/15/Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB/</id>
    <published>2020-03-15T01:46:08.000Z</published>
    <updated>2022-08-13T12:29:03.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx处理静态页面，Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种：</p><ul><li>纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；</li><li>把动态跟静态文件混合在一起发布，通过 nginx 来分开。通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码 200。</li></ul><h3 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h3><h4 id="2-1、需求"><a href="#2-1、需求" class="headerlink" title="2.1、需求"></a>2.1、需求</h4><p>使用 nginx（192.168.150.101）动态分离，在本机（192.168.150.100）访问不同的地址，获取192.168.150.101服务器上不同的静态资源。<br>地址1：<a href="http://www.ld.com/html/index.html">www.ld.com/html/index.html</a><br>地址2：<a href="http://www.ld.com/image/test.png">www.ld.com/image/test.png</a></p><h4 id="2-2、配置"><a href="#2-2、配置" class="headerlink" title="2.2、配置"></a>2.2、配置</h4><ul><li><p>step1：修改本机 hosts 文件，位置：C:\Windows\System32\drivers\etc\，并在文件最后添加如下配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.150.101 www.ld.com</span><br></pre></td></tr></table></figure></li><li><p>step2：修改nginx.conf，在文件中的 http 块中添加如下配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen  80;</span><br><span class="line">    server_name www.ld.com</span><br><span class="line">    #动态资源</span><br><span class="line">    location /html/ &#123;</span><br><span class="line">        root    /data/;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location /image/ &#123;</span><br><span class="line">        root    /data/;</span><br><span class="line">        #打开目录浏览功能</span><br><span class="line">        autoindex on;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>step3：在192.168.150.101服务器根目录下创建data文件夹。</p><p>在data文件夹下创建html文件夹，在html文件夹下添加index.html。index.html内容如下：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=utf-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，我是一个html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    在data文件夹下创建image文件夹，在image文件夹下添加test.png。</p><p><img src="test.png"></p><ul><li><p>step4：在浏览器上访问不同路径显示不同信息，测试如下：</p><p>地址1：<a href="http://www.ld.com/html/index.html">www.ld.com/html/index.html</a></p></li></ul><p><img src="test1.PNG"></p><p>​       地址2：<a href="http://www.ld.com/image/test.png">www.ld.com/image/test.png</a></p><p><img src="test2.PNG"></p><p>​        地址3（浏览目录）：<a href="http://www.ld.com/image/">www.ld.com/image/</a></p><p><img src="test3.PNG"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、概述&quot;&gt;&lt;a href=&quot;#1、概述&quot; class=&quot;headerlink&quot; title=&quot;1、概述&quot;&gt;&lt;/a&gt;1、概述&lt;/h3&gt;&lt;p&gt;Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动</summary>
      
    
    
    
    <category term="Nginx" scheme="https://blog.lee81.cn/categories/Nginx/"/>
    
    
    <category term="Nginx" scheme="https://blog.lee81.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx安装</title>
    <link href="https://blog.lee81.cn/2020/03/14/Nginx%E5%AE%89%E8%A3%85/"/>
    <id>https://blog.lee81.cn/2020/03/14/Nginx%E5%AE%89%E8%A3%85/</id>
    <published>2020-03-14T07:11:13.000Z</published>
    <updated>2022-08-13T12:29:03.583Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h4><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。(来自百度百科)</p><h4 id="2、常用的使用场景"><a href="#2、常用的使用场景" class="headerlink" title="2、常用的使用场景"></a>2、常用的使用场景</h4><ul><li><p>正向代理</p><p>概念：正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。</p></li><li><p>反向代理</p><p>概念：反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。</p></li><li><p>负载均衡</p><p>概念：负载均衡，英文名称为Load Balance，其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。</p></li><li><p>动静分离</p><p>动静分离是指在web服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提升整个服务访问性能和可维护性。</p></li></ul><h4 id="3、下载、安装"><a href="#3、下载、安装" class="headerlink" title="3、下载、安装"></a>3、下载、安装</h4><ul><li>下载<blockquote><p>地址：<a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a></p></blockquote></li><li>安装<blockquote><ol><li>安装相关依赖</li></ol></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>解压</li></ol></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>进入到解压目录，运行configure脚本</li></ol></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><blockquote><ol start="4"><li>编译安装</li></ol></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><blockquote><ol start="5"><li>nginx已经安装完成，安装目录为/usr/local/nginx，目录结构如下：</li></ol></blockquote></li></ul><p><img src="nginx%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.PNG"></p><h4 id="4、常用命令"><a href="#4、常用命令" class="headerlink" title="4、常用命令"></a>4、常用命令</h4><ul><li><p>查看帮助信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -h</span><br></pre></td></tr></table></figure></li><li><p>查看nginx版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -v</span><br></pre></td></tr></table></figure></li><li><p>查看nginx详细版本信息，还显示配置参数信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br></pre></td></tr></table></figure></li><li><p>启动nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></li><li><p>指定配置文件启动nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -c filename</span><br></pre></td></tr></table></figure></li><li><p>优雅停止nginx，有连接时会等连接请求完成再杀死worker进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s quit</span><br></pre></td></tr></table></figure></li><li><p>快速停止nginx，可能并不保存相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop</span><br></pre></td></tr></table></figure></li><li><p>重新载入nginx，当配置信息修改后，需要重新加载配置时使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li><li><p>重新打开日志文件，一般用于切割日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reopen</span><br></pre></td></tr></table></figure></li><li><p>检验配置文件是否有错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t filename</span><br></pre></td></tr></table></figure></li></ul><h4 id="5、配置文件介绍"><a href="#5、配置文件介绍" class="headerlink" title="5、配置文件介绍"></a>5、配置文件介绍</h4><ul><li><p>位置</p><p>安装目录下的 conf 文件夹下的 nginx.conf 文件，在 conf 文件夹下还存放着nginx服务器的其他基础配置。</p></li><li><p>内容</p></li></ul><p>去除注释后的文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    </span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述文件内容，可以将 nginx.conf 配置文件分为三部分。</p><ol><li><p><strong>全局块</strong></p><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 nginx 服务器的用户（组）、允许生成的 worker process 数、进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。</p></li><li><p><strong>events块</strong></p><p>events 块涉及的指令主要影响 nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 worker process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 worker process 可以同时支持的最大连接数等。</p></li><li><p><strong>http块</strong></p><p>这块算是 nginx 服务器配置中最繁琐的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。<br>注意：http 块包括 http 全局块、server 块。每个 http 块可以包括多个 server 块，每个 server 块就相当于一个虚拟主机。</p><ul><li><p><strong>http 全局块</strong><br>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p></li><li><p><strong>server 块</strong><br>server 块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。<br>注意：每个 server 块也分为全局 server 块，以及可以同时包含多个 location 块。</p><ul><li><p><strong>server 全局块</strong><br>最常见的配置是本虚拟主机的监听配置和本虚拟主机的名称或IP配置。</p></li><li><p><strong>location 块</strong><br>location 块主要作用是基于 nginx 服务器接收到请求字符串，对虚拟主机名称之外的字符串进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p></li></ul></li></ul></li></ol><h4 id="6、nginx-keepalived-高可用"><a href="#6、nginx-keepalived-高可用" class="headerlink" title="6、nginx + keepalived 高可用"></a>6、nginx + keepalived 高可用</h4><h5 id="6-1、主从模式"><a href="#6-1、主从模式" class="headerlink" title="6.1、主从模式"></a>6.1、主从模式</h5><p>TODO</p><h5 id="6-2、双主模式"><a href="#6-2、双主模式" class="headerlink" title="6.2、双主模式"></a>6.2、双主模式</h5><p>TODO</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1、简介&quot;&gt;&lt;a href=&quot;#1、简介&quot; class=&quot;headerlink&quot; title=&quot;1、简介&quot;&gt;&lt;/a&gt;1、简介&lt;/h4&gt;&lt;p&gt;Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务</summary>
      
    
    
    
    <category term="Nginx" scheme="https://blog.lee81.cn/categories/Nginx/"/>
    
    
    <category term="安装" scheme="https://blog.lee81.cn/tags/%E5%AE%89%E8%A3%85/"/>
    
    <category term="Nginx" scheme="https://blog.lee81.cn/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Maven离线开发</title>
    <link href="https://blog.lee81.cn/2020/03/11/Maven%E7%A6%BB%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    <id>https://blog.lee81.cn/2020/03/11/Maven%E7%A6%BB%E7%BA%BF%E5%BC%80%E5%8F%91/</id>
    <published>2020-03-11T02:45:16.000Z</published>
    <updated>2022-08-13T12:29:03.574Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h3><p>开始在有网环境下开发项目，后面因为各种原因，需要在无网环境下进行开发，因此需要在无网环境下运行Maven项目。</p><h3 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h3><h4 id="2-1、配置setting-xml"><a href="#2-1、配置setting-xml" class="headerlink" title="2.1、配置setting.xml"></a>2.1、配置setting.xml</h4><ol><li>设置本地仓库路径。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>本地仓库路径<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>设置镜像地址指向本地仓库路径。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>central<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>central<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://本地仓库路径<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2、准备本地仓库"><a href="#2-2、准备本地仓库" class="headerlink" title="2.2、准备本地仓库"></a>2.2、准备本地仓库</h4><p>在有网环境下下载好项目依赖的所有jar包，然后导入到无网环境下的本地仓库路径下。</p><h4 id="2-3、修改idea配置"><a href="#2-3、修改idea配置" class="headerlink" title="2.3、修改idea配置"></a>2.3、修改idea配置</h4><ol><li>修改maven配置，勾选 Work offline。</li></ol><p><img src="1.PNG"></p><ol start="2"><li>修改配置文件路径为上文修改的setting.xml文件路径。</li></ol><p><img src="2.PNG"></p><ol start="3"><li>重启idea,就可以使用了。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、背景&quot;&gt;&lt;a href=&quot;#1、背景&quot; class=&quot;headerlink&quot; title=&quot;1、背景&quot;&gt;&lt;/a&gt;1、背景&lt;/h3&gt;&lt;p&gt;开始在有网环境下开发项目，后面因为各种原因，需要在无网环境下进行开发，因此需要在无网环境下运行Maven项目。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="Maven" scheme="https://blog.lee81.cn/categories/Maven/"/>
    
    
    <category term="Maven" scheme="https://blog.lee81.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu共享目录</title>
    <link href="https://blog.lee81.cn/2020/03/03/Ubuntu%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/"/>
    <id>https://blog.lee81.cn/2020/03/03/Ubuntu%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95/</id>
    <published>2020-03-03T11:14:03.000Z</published>
    <updated>2022-08-13T12:29:03.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、samba-安装"><a href="#1、samba-安装" class="headerlink" title="1、samba 安装"></a>1、samba 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install samba</span><br></pre></td></tr></table></figure><h3 id="2、创建共享目录"><a href="#2、创建共享目录" class="headerlink" title="2、创建共享目录"></a>2、创建共享目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [目录]</span><br></pre></td></tr></table></figure><h3 id="3、修改samba配置文件"><a href="#3、修改samba配置文件" class="headerlink" title="3、修改samba配置文件"></a>3、修改samba配置文件</h3><blockquote><ol><li>备份默认配置文件</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak</span><br></pre></td></tr></table></figure><blockquote><ol start="2"><li>编辑配置文件</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><blockquote><ol start="3"><li>在文件最后添加</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[share]</span><br><span class="line">    path = [共享目录]    </span><br><span class="line">    available = yes      </span><br><span class="line">    browsealbe = yes      </span><br><span class="line">    public = yes      </span><br><span class="line">    writable = yes</span><br><span class="line">    comment = [共享目录描述]</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><blockquote><p>推荐为共享目录创建指定的用户，修改共享目录的权限为指定用户。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、samba-安装&quot;&gt;&lt;a href=&quot;#1、samba-安装&quot; class=&quot;headerlink&quot; title=&quot;1、samba 安装&quot;&gt;&lt;/a&gt;1、samba 安装&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tabl</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.lee81.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.lee81.cn/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.lee81.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Linux硬盘挂载</title>
    <link href="https://blog.lee81.cn/2020/03/01/Linux%E7%A1%AC%E7%9B%98%E6%8C%82%E8%BD%BD/"/>
    <id>https://blog.lee81.cn/2020/03/01/Linux%E7%A1%AC%E7%9B%98%E6%8C%82%E8%BD%BD/</id>
    <published>2020-03-01T01:21:19.000Z</published>
    <updated>2022-08-13T12:29:03.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、查看硬盘"><a href="#1、查看硬盘" class="headerlink" title="1、查看硬盘"></a>1、查看硬盘</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><h3 id="2、分区"><a href="#2、分区" class="headerlink" title="2、分区"></a>2、分区</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用parted来对GPT磁盘操作，进入交互式模式</span></span><br><span class="line">sudo parted /dev/[设备名] </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将磁盘格式化为GPT</span></span><br><span class="line">(parted) mklabel gpt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将所有容量分为一个主分区</span></span><br><span class="line">(parted) mkpart primary ext4 0% 100%</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印当前分区</span></span><br><span class="line">(parted) p</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">退出</span></span><br><span class="line">(parted) q</span><br></pre></td></tr></table></figure><h3 id="3、格式化"><a href="#3、格式化" class="headerlink" title="3、格式化"></a>3、格式化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfs.ext4 /dev/[分区名]</span><br></pre></td></tr></table></figure><h3 id="4、挂载"><a href="#4、挂载" class="headerlink" title="4、挂载"></a>4、挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在根目录创建一个文件夹</span></span><br><span class="line">sudo mkdir /data</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将磁盘分区挂载到文件夹下</span></span><br><span class="line">sudo mount /dev/[分区名] /data</span><br></pre></td></tr></table></figure><h3 id="5、查看UUID"><a href="#5、查看UUID" class="headerlink" title="5、查看UUID"></a>5、查看UUID</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo blkid</span><br></pre></td></tr></table></figure><h3 id="6、修改-etc-fstab"><a href="#6、修改-etc-fstab" class="headerlink" title="6、修改/etc/fstab"></a>6、修改/etc/fstab</h3><blockquote><p>在fstab文件的最后添加一行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=cf116c95-b7f0-4ce4-b0da-7f2856784cc3   /data   ext4    defaults    0 2</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、查看硬盘&quot;&gt;&lt;a href=&quot;#1、查看硬盘&quot; class=&quot;headerlink&quot; title=&quot;1、查看硬盘&quot;&gt;&lt;/a&gt;1、查看硬盘&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.lee81.cn/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://blog.lee81.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
