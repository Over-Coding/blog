---
title: Zookeeper使用场景
date: 2020-04-25 10:57:22
categories:
	- Zookeeper
tags: 
	- Zookeeper
	- 使用场景
toc: true
typora-root-url: Zookeeper使用场景
---





学 Zookeeper 就是为了用它，接下来我就介绍以下常用的使用场景。

### 1、数据发布/订阅

#### 1.1、介绍

数据发布/订阅，顾名思义就是发布者将数据发布到 Zookeeper 上，然后供订阅者进行数据订阅和监控，进而实现动态改变和获取数据的目的。

#### 1.2、示例

**需求：**当我们部署集群时，需要重复修改每个节点的配置信息，节点少的时候还好，如果多了，并且需要修改频繁的时候就会很浪费时间。此时以数据库连接信息为例，连接信息包括：IP地址，端口号，用户名，密码，数据库名称。

**解决：** 为解决上述需求，我们可以引入 Zookeeper 作为配置中心，将所有的配置信息都发布到 Zookeeper 上，然后供集群所有节点进行数据订阅和监控，当需要修改配置时，只需修改 Zookeeper 上的数据，就可以触发所有节点进行修改。

![](注册中心.png)

设计思路如下：

1. 创建一个永久节点（mysql）表示为数据库连接信息。
2. 在 mysql 节点下创建多个子节点，表示IP地址，端口号，用户名，密码，数据库名称。
3. 所有的客户端都获取 mysql 节点下的子节点信息，并注册监控事件。
4. 当数据库连接信息有变化时，所有客户端都能被触发，重新执行步骤3。



### 2、Master选举

#### 2.1、介绍

Master 选举就是从集群中选出一个所谓的 "老大"，这里称之为 Master，Master 往往用来协调集群中其他系统单元，具有对分布式系统状态变更的决定权。



#### 2.2、示例

**需求：**需要从集群选出一个节点作为主节点 (Master)，来处理工作，其他节点作为从节点，当主节点挂掉时，其他节点接着竞选主节点。

**解决：** 为解决上述需求，我们可以引入 Zookeeper 服务，通过所有节点竞争创建同一个节点（Master），创建成功的为主节点，其他节点只能监控 Master 节点，当 Master 节点被删除时，接着去竞争创建。

![](Master选举.png)

设计思路如下：

1. 创建一个永久节点（App1）表示为App1集群。
2. 集群中的所有节点都竞争创建名为 Master 的临时节点（这里设计为临时节点的原因是当主节点宕机时，临时节点也就跟着被删除了）。
3. 创建成功 Master 节点的集群节点就是主节点，处理功能，当然还可以将主节点的一些本地信息存储到 Master 节点中，供监控系统展示主节点信息。
4. 其他集群节点就对 Master 节点注册监控。
5. 当Master 节点删除时，其他节点都收到通知，重新执行步骤2。



### 3、分布式锁

#### 3.1、介绍

分布式锁是控制分布式系统之间同步访问共享资源的一种方式。比如你的项目为单体应用是，就可以使用Synchronize 或者 Lock 锁来实现同步访问共享资源。但是如果是分布式应用，多个应用之间如果想同步访问共享资源时 Synchronize 和 Lock 就不管用了，所以就提出了分布式锁的概念。现在实现分布式锁的方式有很多种，比如：Redis，数据库，Zookeeper。这里只说 Zookeeper 实现分布式锁的思路。



#### 3.2、示例

**需求：**当一个分布式系统中，需要同步访问共享某一个资源时，怎么才能防止并发问题呢？

**解决：**如果理解了上面的 Master 选举的思想，应该就明白 Zookeeper 怎么实现分布式锁了（创建指定节点，创建成功的线程就是获取到锁）。但是如果使用上面的方式实现的话有一个问题，如果现在有成千上百个线程同时获取分布式锁时，就会出现**羊群效应**。

**羊群效应：**当并发量比较高时，当线程释放锁时，其他所有的线程都需要抢占锁（即创建锁节点），就会出现大量的创建请求，所以就出现了羊群效应。如何解决羊群效应呢？请看下图：

![](分布式锁.png)

设计思路如下：

1. 当线程需要获取锁时，就创建一个节点路径为 lock 的临时有序节点（使用临时节点是为了防止死锁的问题）。
2. 获取 /MyLock 的子节点列表。
3. 判断自己创建的节点是否为第一个。
4. 如果是第一个，说明获取到了锁，执行业务代码。
5. 如果不是第一个，就对自己的前一个节点注册监控，当前一个节点删除时，就重新执行步骤2。
6. 当执行完业务代码时，删除自己创建的节点。

这样每次释放锁，就不会让其他所有线程都去抢占锁，只需要让下一个节点去抢占锁就可以了。避免了羊群效应。

**注意：上面讲述的是排他锁，只有一个线程能获取到锁。如果想实现读写锁，该怎么进行变形呢？自己可以尝试思考一下。**



### 4、分布式唯一性ID

#### 4.1、介绍

在过去的单库单表型系统中，通常可以使用数据库字段自带的auto_increment属性来自动为每条记录生成一个唯一的ID。但是分库分表后，就无法在依靠数据库的auto_increment属性来唯一标识一条记录了。此时我们就可以用zookeeper在分布式环境下生成全局唯一ID。



#### 4.2、示例

![](分布式唯一性ID.png)

设计思路如下：

1. 当需要生成唯一性ID 时，就在 /MyID 节点下创建一个节点路径为 id 的持久有序节点。
2. 获取创建后的节点路径。
3. 将节点路径的前缀 id 截取，留下的就是唯一性 ID。
4. 然后删除比自己小的节点。

**也可以使用 /MyID 中的版本号来实现 唯一性 ID。**