---
title: 记一道笔试题
date: 2020-08-21 23.06.01
categories:
	- 笔试题
tags: 
	- 笔试题
---



今天参加了一场笔试，有一道题写出来了，但是有些小问题，在这里记录一下。



### 1、题目

创建一个线程类，实例化三个线程A,B,C，要求线程A打印A，线程B打印B，线程C打印C，然后开启线程的顺序为C -> B -> A，打印结果为：

A

B

C



### 2、错误思路

看到题目的时候，我的第一反应是使用线程通信去做，然后就有了下面的代码。

```java
public class Test {
    public static void main(String[] args) {
        //创建三个线程
        MyThread a = new MyThread("A");
        MyThread b = new MyThread("B");
        MyThread c = new MyThread("C");
        //开启线程，按 C->B->A的顺序开启
        c.start();
        b.start();
        a.start();
    }

}


class MyThread extends Thread{
    //创建锁
    private static ReentrantLock lock = new ReentrantLock();
    private static Condition condition = lock.newCondition();

	//创建临时标识，用于表示当前执行那个线程
    private static volatile int flag = 0;

    private String msg;

    public MyThread(String msg){
        this.msg = msg;
    }

    public void run() {
        lock.lock();
        try {
            while (true) {
            	//如果flag为0，并且是线程A
                if (flag == 0 && "A".equals(msg)) {
                    //打印A
                    System.out.println(msg);
                    //将flag设置为1
                    flag = 1;
                    //唤醒其他线程
                    condition.signal();
                    break;
                } else if (flag == 1 && "B".equals(msg)) {//如果flag为1，并且是线程B
                    //打印B
                    System.out.println(msg);
                    //将flag设置为2
                    flag = 2;
                    //唤醒其他线程
                    condition.signal();
                    break;
                } else if (flag == 2 && "C".equals(msg)) {//如果flag为2，并且是线程C
                    //打印C
                    System.out.println(msg);
                    break;
                } else {
                	//如果是其他情况就阻塞住当前线程
                    condition.await();
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //释放锁
            lock.unlock();
        }
    }
}
```



### 3、正确解法

面试官说有些问题，所以我就进行了改进，代码如下：

```java
public class Test {
    public static void main(String[] args) {
        //创建三个线程
        MyThread a = new MyThread("A");
        MyThread b = new MyThread("B");
        MyThread c = new MyThread("C");
        //开启线程，按 C->B->A的顺序开启
        c.start();
        b.start();
        a.start();
    }

}


class MyThread extends Thread{
    //创建锁
    private static ReentrantLock lock = new ReentrantLock();
    private static Condition conditionB = lock.newCondition();
    private static Condition conditionC = lock.newCondition();

	//创建临时标识，用于表示当前执行那个线程
    private static volatile int flag = 0;

    private String msg;

    public MyThread(String msg){
        this.msg = msg;
    }

    public void run() {
        lock.lock();
        try {
            while (true) {
            	//如果flag为0，并且是线程A
                if (flag == 0 && "A".equals(msg)) {
                    //打印A
                    System.out.println(msg);
                    //将flag设置为1
                    flag = 1;
                    //唤醒B线程
                    conditionB.signal();
                    break;
                } else if (flag == 1 && "B".equals(msg)) {//如果flag为1，并且是线程B
                    //打印B
                    System.out.println(msg);
                    //将flag设置为2
                    flag = 2;
                    //唤醒C线程
                    conditionC.signal();
                    break;
                } else if (flag == 2 && "C".equals(msg)) {//如果flag为2，并且是线程C
                    //打印C
                    System.out.println(msg);
                    break;
                } else {//如果上面的情况不符合，就要阻塞当前线程
                	//如果当前线程为B，并且flag不为1，就阻塞
                    if(flag != 1 && "B".equals(msg)){
                        conditionB.await();
                    }
                    //如果当前线程为C，并且flag不为2，就阻塞
                    if(flag != 2 && "C".equals(msg)){
                        conditionC.await();
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //释放锁
            lock.unlock();
        }
    }
}
```



### 4、其他解法

```java
public class Main {

    public static void main(String[] args){
        Print print = new Print();
        //开启线程C
        new Thread(() -> {
            print.printC();
        },"C").start();

        //开启线程B
        new Thread(() -> {
            print.printB();
        },"B").start();

        //开启线程A
        new Thread(() -> {
            print.printA();
        },"A").start();
    }
}

class Print{

    private ReentrantLock lock = new ReentrantLock();
    private Condition conditionA = lock.newCondition();
    private Condition conditionB = lock.newCondition();
    private Condition conditionC = lock.newCondition();

    private volatile int flag = 0;

    /**
     * 打印A
     */
    public void printA(){
        //获取锁
        lock.lock();
        try{
            //如果flag不为0，就将当前线程等待
            while(flag != 0){
                try {
                    conditionA.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //打印a
            System.out.println("A");
            //将flag设置为1
            flag = 1;
            //唤醒B线程
            conditionB.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            //释放锁
            lock.unlock();
        }
    }

    /**
     * 打印B
     */
    public void printB(){
        //获取锁
        lock.lock();
        try{
            //如果flag不为1，就将当前线程等待
            while(flag != 1){
                try {
                    conditionB.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //打印a
            System.out.println("B");
            //将flag设置为2
            flag = 2;
            //唤醒C线程
            conditionC.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            //释放锁
            lock.unlock();
        }
    }
    /**
     * 打印C
     */
    public void printC(){
        //获取锁
        lock.lock();
        try{
            //如果flag不为2，就将当前线程等待
            while(flag != 2){
                try {
                    conditionC.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //打印a
            System.out.println("C");
            //将flag设置为0
            flag = 0;
            //唤醒C线程
            conditionA.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            //释放锁
            lock.unlock();
        }
    }
}
```



### 5、总结

这场面试我是非常看重的，但是因为当时家里断网，加上自己紧张，没有做出来，不说了，都是泪。归根到底就是一句话还是自己太菜，不找任何理由，继续加油吧。



### 6、后续

第二天我又研究了一下我写错的代码，发现我只是用错了一个方法，就是将代码中的 signal() 修改为 signalAll() 即可，代码如下：

```java
public class Test {
    public static void main(String[] args) {
        //创建三个线程
        MyThread a = new MyThread("A");
        MyThread b = new MyThread("B");
        MyThread c = new MyThread("C");
        //开启线程，按 C->B->A的顺序开启
        c.start();
        b.start();
        a.start();
    }

}


class MyThread extends Thread{
    //创建锁
    private static ReentrantLock lock = new ReentrantLock();
    private static Condition condition = lock.newCondition();

	//创建临时标识，用于表示当前执行那个线程
    private static volatile int flag = 0;

    private String msg;

    public MyThread(String msg){
        this.msg = msg;
    }

    public void run() {
        lock.lock();
        try {
            while (true) {
            	//如果flag为0，并且是线程A
                if (flag == 0 && "A".equals(msg)) {
                    //打印A
                    System.out.println(msg);
                    //将flag设置为1
                    flag = 1;
                    //唤醒其他线程，错误就在这里，只需修改为signalAll()就可以了
                    condition.signalAll();
                    break;
                } else if (flag == 1 && "B".equals(msg)) {//如果flag为1，并且是线程B
                    //打印B
                    System.out.println(msg);
                    //将flag设置为2
                    flag = 2;
                    //唤醒其他线程,这里也是一样
                    condition.signalAll();
                    break;
                } else if (flag == 2 && "C".equals(msg)) {//如果flag为2，并且是线程C
                    //打印C
                    System.out.println(msg);
                    break;
                } else {
                	//如果是其他情况就阻塞住当前线程
                    condition.await();
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //释放锁
            lock.unlock();
        }
    }
}
```

